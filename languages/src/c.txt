# The C language, according to the C11 standard
# See http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf
# Compile to c.bin and copy that to h.bin.

# Potential keywords: go to key state to check if really identifiers
start  _Alignas _Atomic _Bool _Complex _Generic _Imaginary    key
start  _Noreturn _Static_assert _Thread_Local alignof auto    key
start  bool break case char const continue default do double  key
start  else extern false float for goto if inline int long    key
start  register restrict return short signed sizeof static    key
start  switch true typedef unsigned void volatile while       key

# Keywords which may be followed by curly bracket declarations.
start struct union enum decl

# Operators
start != ! % && &= & *= * ++ += + -- -= - /= /  start +
start <<= << <= < == >= >>= >> > ^= ^ |= || | ~ start +

# Key symbols
start ## %:%: %= , ... : ; ?? ? start S
start -> arrow S
start = init S
start : start :
start ( start (
start ) start )
start [ <: start [
start ] :> start ]
start { <% start {
start } %> start }

# Identifiers, numbers, preprocessor lines, white space
start a..z A..Z _ \bU \bu id
start 0..9 num
start . dot
start # %: hash R
start \s gap

# Quotes, escape sequences, comments, white space, illegal characters
start ' start '
start " start "
start \ escape
start /* start <
start */ start >
start // start #
start \n start $
start \s..~ start ?
start start ?

# Spaces form a gap token.
gap \s gap
gap start _

# Potential keywords, if not followed by alphanumerics.
key a..z A..Z 0..9 id
key _ \bU \bu id
key start K

# Identifiers
id a..z A..Z 0..9 _ \bU \bu id
id idGap I

# Lookahead after id for following open bracket or id
idGap \s idGap
idGap \n idGap
idGap idNext

idNext ( call \r
idNext a..z A..Z 0..9 _ \bU \bu type \r
idNext normal \r

call start F
type start T
normal start I

# A dot starts a number, or is a symbol possibly followed by a field.
dot 0..9 num
dot dotField S

dotField a..z A..Z 0..9 _ \bU \bu dotField
dotField start D

# An arrow -> may be followed by a field.
arrow a..z A..Z 0..9 _ \bU \bu arrow
arrow start D

# Numbers with possible exponents.
num . 0..9 num
num e+ e- E+ E- num
num p+ p- P+ P- num
num start N

# Escape sequences: single character, hex, octal, or merge lines
escape a..w y..z start E
escape x escapex
escape 0..7 escape1
escape start E

# Octal escape sequences: up to three digits.
escape1 0..7 escape2
escape1 start E
escape2 0..7 start E
escape2 start E

# Hex escape sequences: any number of digits
escapex 0..9 a..f A..F escapex
escapex start E

# A hash is followed by spaces then a preprocessor keyword.
hash \s hash
hash include include R
hash define elif else endif error if start R
hash ifdef ifndef start line pragma undef start R
hash start R

# After #include, aim to tag <file> as a string.
include \s include
include fileStart _
fileStart < file "
fileStart start
file \s..= ?..~ file
file fileEnd I
fileEnd > start "
fileEnd start ?

# Look for curly brackets used in structure, union or enum declarations
# (which require terminating semicolons). Recognize "struct id? {",
# "union id? {", "enum id? {".

# Seen struct/union/enum
decl a..z A..Z 0..9 _ \bU \bu id
decl declGap K

# Seen struct/union/enum as a keyword
declGap \s declGap
declGap \n declGap $
declGap declId _

# Seen struct/union/enum and a gap
declId a..z A..Z 0..9 _ \bU \bu declId
declId declIdGap I

# Seen struct/union/enum and an id
declIdGap \s declIdGap
declIdGap \n declIdGap $
declIdGap declCurly _

# Seen struct/union/enum and an id and a gap
declCurly { start %
declCurly start

# Look for curly brackets used in an initializer. Recognize "= {" or "= (s) {"
# or "= (struct s) {".

# Seen "="
init \s init
init \n init $
init initCast _

# Seen "= "
initCast { start %
initCast ( initCastGap (
initCast start

# Seen "= ("
initCastGap \s initCastGap
initCastGap \n initCastGap $
initCastGap initType _

# Seen "= ( "
initType struct initStruct _
initType a..z A..Z 0..9 _ \bU \bu initId
initType start

# Seen "= (struct"
initStruct a..z A..Z 0..9 _ \bU \bu initId
initStruct initStructGap K

# Seen "= (struct "
initStructGap \s initStructGap
initStructGap \n initStructGap $
initStructGap initId _

# Seen "= (x" or "= (struct x"
initId a..z A..Z 0..9 _ \bU \bu initId
initId initIdGap I

# Seen "= (id" or "= (struct id"
initIdGap \s initIdGap
initIdGap \n initIdGap $
initIdGap initClose _

# Seen "= (id " or "= (struct id "
initClose ) initCloseGap
initClose start

# Seen "= (id)" or "= (struct id)"
initCloseGap \s initCloseGap
initCloseGap \n initCloseGap $
initCloseGap initCurly _

# Seen "= (id) " or "= (struct id) "
initCurly { start %
initCurly start

-------------------------------------------------------------------------------
abc
I

(def)
(I  )

if (b) n = 1;
K _(I)_I_S_NS

if (b) { n = 1; }
K _(I)_{_I_S_NS_}

int n;
K  _IS

string s;
T     _IS

enum suit { Club, Diamond, Heart, Spade };
K   _I   _%_I   S_I      S_I    S_I    _}S

int ns[] = { 1, 2, 34};
K  _I []_S_%_NS_NS_N }S

char *s = "a\nb\0c\04d\037e\038f\xffg"
K   _+I_S_"IE IE IE  IE   IE  NIE   I"

/* abc "*/"//"
< _I  _"> "# "

obj.field, obj->field, function(arg)
I  SD    S_I  S D    S_F       (I  )

#include <stdio.h>
RR      _"I      "
