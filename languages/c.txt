// C language definition, based on the C11 standard
// See http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf
// The source text is assumed to be normalised, with no control characters
// other than \n and no digraphs or trigraphs.

// Keywords which are types or related to types. Include bool from <stdbool.h>.
// The type state checks for additional characters, making the token an id.

start   _Atomic _Bool _Complex _Generic _Imaginary      type
start   bool char double float int long                 type
start   short signed unsigned void                      type
type    a..z A..Z 0..9 _ \\U \\u                        id
type    \                                               start TYPE

// Other keywords. Include false, true from <stdbool.h>. The enum and struct
// keywords cause bracket checking. The key state checks for added characters.

start   _Alignas _Noreturn _Static_assert _Thread_Local         key
start   alignof auto break case const continue default do else  key
start   extern false for goto if inline register restrict       key
start   return sizeof static switch true typedef union          key
start   volatile while                                          key
start   enum struct                                             key2
key     a..z A..Z 0..9 _ \\U \\u                                id
key     \                                                       start KEY
key2    a..z A..Z 0..9 _ \\U \\u                                id
key2    \                                                       check0 KEY

// Operators and signs. A + or - is marked infix, and a ++ or -- is marked
// nonfix, for semicolon insertion, on the assumption that when it has one
// operand, it won't be separated by a newline from the operand.

start   ++ -- ! ~                                   start UNARY
start   != %= % && &= & *= * += + -= - /= / ?       start OP
start   <<= << <= < == >= >>= >> > ^= ^ |= || |     start OP
start   ...                                         start MARK
start   ## , ; : ->                                 start SIGN
start   =                                           check3 SIGN

// Identifiers

start   a..z A..Z _ \\U \\u        id
id      a..z A..Z 0..9 _ \\U \\u   id
id      \                          start ID

// Brackets. By default { and } are block brackets. To help with semicolon
// insertion, the opener { is marked as an inline bracket LEFT instead, by the
// rules below. The closer } is changed from END to RIGHT to match by Snipe
// during bracket matching.

start  {   start BEGIN
start  }   start END
start  [   start LEFT
start  ]   start RIGHT
start  (   start LEFT
start  )   start RIGHT

// Check for structure brackets  enum {  or  struct {
check0    {                          start LEFT
check0    a..z A..Z _ \\U \\u        check1
check0    \s \n                      check0
check0    \                          start

// Check for  enum e  or  struct s
check1    a..z A..Z 0..9 _ \\U \\u   check1
check1    \                          check2 ID

// Check for structure brackets  enum e {  or  struct s {
check2    {                          start LEFT
check2    \s \n                      check2
check2    \                          start

// Check for structure bracket  = {
check3    {                          start LEFT
check3    (                          check4 LEFT
check3    \s \n                      check3
check3    \                          start

// Check for   = (   or   = (struct
check4    struct                     check4 KEY
check4    a..z A..Z _ \\U \\u        check5
check4    \s \n                      check4
check4    \                          start


// Check for   = (t   or   = (struct s
check5    a..z A..Z 0..9 _ \\U \\u   check5
check5    \                          check6 ID

// Check for   = (t)   or   = (struct s)
check6    )                          check7 RIGHT
check6    \s \n                      check6
check6    \                          start

// Check for   = (t) {   or   = (struct s) {
check7    {                          start LEFT
check7    \                          start

// A dot starts a number, or is an operator.

start   .      dot
dot     \0..9  decimal
dot     \      start OP

// Character and string literals.

start   '         char1
char0   !..~ \\'  char1
char0   \s        char0
char0   '         start QUOTE
char0   \n        start
char1   !..~ \\'  char1
char1   \s        char0 QUOTE
char1   '         start QUOTE
char1   \n        start WRONG

start     "          string1
string0   !..~ \\"   string1
string0   \s         string0
string0   "          start QUOTE
string0   \n         start
string1   !..~ \\"   string1
string1   \s         string0 QUOTE
string1   "          start QUOTE
string1   \n         start WRONG

// One-line comment.

start    //     note0 NOTE
note0    !..~   note1
note0    \s     note0
note0    \n     start
note1    !..~   note1
note1    \s     note0 NOTE
note1    \n     start NOTE

// Multi-line comment.

start      /*      comment0 COMMENT
comment0   !..~    comment1
comment0   \s \n   comment0
comment0   */      start COMMENT
comment1   !..~    comment1
comment1   \s \n   comment0 COMMENT
comment1   \*/     comment0 COMMENT

// Numbers. There is no attempt to detect malformed numbers.
start    0..9           decimal
start    0x 0X          hex
decimal  0..9 .         decimal
decimal  e+ e- E+ E-    decimal
decimal  u U l L ll LL  decimal
decimal  \              start VALUE
hex      0..9 .         hex
hex      a..f A..F      hex
hex      p+ p- P+ P-    hex
hex      u U l L ll LL  hex
hex      \              start VALUE

// Reserved words. Preprocessor tokens are handled as normal tokens, except for
// <filename> after #include.

start     #                                 hash MARK
hash      \s                                hash
hash      include                           include MARK
hash      define elif else endif error if   start MARK
hash      ifdef ifndef line pragma undef    start MARK
hash      \                                 start

include   <                                 filename0 QUOTE
include   \s                                include
include   \                                 start

filename0  !..~                             filename1
filename0  >                                start QUOTE
filename0  \s                               filename0
filename0  \n                               start

filename1  !..~                             filename1
filename1  \> \s                            filename0 QUOTE
filename1  \n                               start WRONG

// Backslash newline is only supported between tokens (only needed for #define)

start \\ start JOIN

// Illegal characters and white space.
start     $ @ `   start WRONG
start     \s \n   start

// ---------- Tests ------------------------------------------------------------
// In the expected output for a test, the start of each token is marked by the
// first letter of its type. Remaining characters are marked with space, a
// space is marked with an underline, and a newline is marked with a dot.

// A few tokens
> (count+1)
< LI    OVR.

// An id can start with a type or keyword
> char chart for form
< T   _I    _K  _I   .

// Operators and signs of different fixities
> ++!<<=...->
< U UO  M  S .

// Structure and block brackets (left structure bracket marked L)
> s={}; do{}
< ISLES_K BE.

// More left structure brackets
> enum{  struct{  enum E{  struct S{
< K   L__K     L__K   _IL__K     _IL.

// More left structure brackets
> ={ =(t){ =(struct t){
< SL_SLIRL_SLK     _IRL.

// Dot as sign or as part of number
> s.x 1.2 .2
< IOI_V  _V .

// Character literals, including unclosed at end of line
> 'x' '\'' 'x
< Q  _Q   _W .

// String literals, including unclosed
> "hello world" "a\"b" "unclosed
< Q     _Q     _Q     _W        .

// One line comment
> n = 0; // note
< I_S_VS_N _N   .

// Multi-line comment
> n = 0; /* line one
< I_S_VS_C _C   _C  .
> line two */ n = 1;
< C   _C  _C _I_S_VS.

// Numbers
> 42 1.2e+3 4.5E-6 0x7f 0x7F 0x7c.def 0xa.bcp+d 0xaU 0xaL 
< V _V     _V     _V   _V   _V       _V        _V   _V   .

// Reserved words (there can be spaces between # and a reserved word)
> #if # else #define #include
< MM _M_M   _MM     _MM      .

// Include filename
> #include <f> #include <one two.ext>
< MM      _QQQ_MM      _QQ  _Q      Q.

// Joiner
> #define f(x) \
< MM     _ILIR_J.

// Illegal characters
> $ @ `
< W_W_W.

// Leading spaces
>    x
< ___I.

// A few general tests

> if (b) n = 1;
< K _LIR_I_S_VS.

> if (b) { n = 1; }
< K _LIR_B_I_S_VS_E.

> int n;
< T  _IS.

> string s;
< I     _IS.

> enum suit { Club, Diamond, Heart, Spade };
< K   _I   _L_I   S_I      S_I    S_I    _ES.

> int ns[] = { 1, 2, 34};
< T  _I LR_S_L_VS_VS_V ES.

> char *s = "a\nb\0c\04d";
< T   _OI_S_Q            S.

> char *s = "\037e\038f\xffg";
< T   _OI_S_Q                S.

> s = "*/"//"; /* abc "*/"//";
< I_S_Q   N N _N _N  _N       .

> /*  "*/"//"; /* abc "*/"//";
< C __CC Q   S_C _C  _CC Q   S.

> obj.x, obj->x, f(x)
< I  OIS_I  S IS_ILIR.

> n = f   (x);
< I_S_I___LIRS.
