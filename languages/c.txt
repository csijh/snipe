// C language definition, based on the C11 standard.

// It is assumed that there are no digraphs or trigraphs (or that they are
// handled by some form of preprocessing). Line joiners (i.e. backslash before
// newline) are assumed never to occur in pathological situations such as in
// the middle of keywords.

// -----------------------------------------------------------------------------

// Keywords which are types or related to types. Include bool from <stdbool.h>.
// The type state checks for added characters which make the token an id.

start   _Atomic _Bool _Complex _Generic _Imaginary      type
start   bool char double float int long                 type
start   short signed unsigned void                      type
type    a..z A..Z 0..9 _ \\U \\u                        id
type    \                                               start TYPE

// Other keywords. Include false, true from <stdbool.h>. The key states check
// for added characters. The enum and struct keywords cause bracket checking.

start   _Alignas _Noreturn _Static_assert _Thread_Local         key
start   alignof auto break case const continue default do else  key
start   extern false for goto if inline register restrict       key
start   return sizeof static switch true typedef union          key
start   volatile while                                          key
start   enum struct                                             key1
key     a..z A..Z 0..9 _ \\U \\u                                id
key     \                                                       start KEY
key1    a..z A..Z 0..9 _ \\U \\u                                id
key1    \                                                       decl KEY

// Identifiers

start   a..z A..Z _ \\U \\u        id
id      a..z A..Z 0..9 _ \\U \\u   id
id      \                          start ID

// Operators and signs. A + or - is marked infix, and a ++ or -- is marked
// nonfix, for semicolon insertion, on the assumption that when it has one
// operand, it won't be separated by a newline from the operand.

start   ++ -- ! ~                                   start UNARY
start   != %= % && &= & *= * += + -= - /= / ?       start OP
start   <<= << <= < == >= >>= >> > ^= ^ |= || |     start OP
start   ...                                         start MARK
start   ## , ; : ->                                 start SIGN
start   =                                           init  OP

// Brackets. By default { and } are block brackets. To help with semicolon
// insertion, the opener { is marked as an inline bracket LEFT instead, by the
// rules below. The closer } is changed from END to RIGHT to match by Snipe
// during bracket matching.

start  {   start BEGIN
start  }   start END
start  [   start LEFT
start  ]   start RIGHT
start  (   start LEFT
start  )   start RIGHT

// Check for declaration brackets  enum {  or  struct {
decl   {                           start LEFT
decl   a..z A..Z _ \\U \\u         decl1
decl   \s \n                       decl
decl   \                           start

// Check for  enum ID  or  struct ID
decl1   a..z A..Z 0..9 _ \\U \\u   decl1
decl1   \                          decl2 ID

// Check for  enum ID {  or  struct ID {
decl2   {                          start LEFT
decl2   \s \n                      decl2
decl2   \                          start

// Check for initialiser brackets  = {
init    {                          start LEFT
init    (                          init1 LEFT
init    \s \n                      init
init    \                          start

// Check for   = (   or   = (struct
init1   struct                     init1 KEY
init1   a..z A..Z _ \\U \\u        init2
init1   \s \n                      init1
init1   \                          start

// Check for   = (ID   or   = (struct ID
init2   a..z A..Z 0..9 _ \\U \\u   init2
init2   \                          init3 ID

// Check for   = (ID)   or   = (struct ID)
init3   )                          init4 RIGHT
init3   \s \n                      init3
init3   \                          start

// Check for   = (ID) {   or   = (struct ID) {
init4   {                          start LEFT
init4   \                          start

// A dot starts a number, or is an operator.

start   .      dot
dot     \0..9  decimal
dot     \      start OP

// Character literals. Allow joiners

start   '      char
char    !..~   char
char    \\     char2
char    \s     char QUOTE
char    '      start QUOTE
char    \n     start QUOTE

// After '...\
char2   \n \s  char3 QUOTE
char2   ' \    char

// After '...\ with a newline next
char3   \n \   char

// String literals. Allow joiners

start     "      string
string    !..~   string
string    \\     string2
string    \s     string QUOTE
string    "      start QUOTE
string    \n     start QUOTE

// After "...\
string2   \n \s  string3 QUOTE
string2   " \    string

// After "...\ with a newline next
string3   \n \   string

// One-line comment. Allow joiner.

start    //     note NOTE
note     !..~   note
note     \\     note2
note     \s     note NOTE
note     \n     start NOTE

note2    \n \s  note3 NOTE
note2    \      note
note3    \n \   note

// Multi-line comment. Allow joiner.

start      /*         comment COMMENT
comment    !..~       comment
comment    \\         comment2
comment    \s \n      comment COMMENT
comment    */         start COMMENT

comment2   \n \s      comment3 COMMENT
comment2   \          comment
comment3   \n \       comment

// Numbers. There is no attempt to detect malformed numbers.
start    0..9           decimal
start    0x 0X          hex
decimal  0..9 .         decimal
decimal  e+ e- E+ E-    decimal
decimal  u U l L ll LL  decimal
decimal  \              start VALUE
hex      0..9 .         hex
hex      a..f A..F      hex
hex      p+ p- P+ P-    hex
hex      u U l L ll LL  hex
hex      \              start VALUE

// Reserved words. Preprocessor tokens are handled as normal tokens, except for
// <filename> after #include.

start     #                                 hash MARK
hash      \s                                hash
hash      include                           include MARK
hash      define elif else endif error if   start MARK
hash      ifdef ifndef line pragma undef    start MARK
hash      \                                 start

include   <                                 filename
include   \s                                include
include   \                                 start

filename  !..~                              filename
filename  >                                 start QUOTE
filename  \s                                filename QUOTE
filename  \n                                start QUOTE

// Backslash newline, e.g. in #define

start \\ start JOIN

// Illegal characters and white space.
start     $ @ `   start WRONG
start     \s \n   start

// ---------- Tests ------------------------------------------------------------
// In the expected output for a test, the start of each token is marked by the
// first letter of its type. Remaining characters are marked with space, a
// space is marked with an underline, and a newline is marked with a dot.

// A few tokens
> (count+1)
< LI----OVR.

// An id can start with a type or keyword
> char chart for form
< T--- I---- K-- I---.

// Operators and signs of different fixities
> ++!<<=...->
< U-UO--M--S-.

// Structure and block brackets (left structure bracket marked L)
> s={}; do{}
< IOLES K-BE.

// More left structure brackets
> enum{  struct{  enum E{  struct S{
< K---L  K-----L  K--- IL  K----- IL.

// More left structure brackets
> ={ =(t){ =(struct t){
< OL OLIRL OLK----- IRL.

// Dot as sign or as part of number
> s.x 1.2 .2
< IOI V-- V-.

// Character literals, including unclosed at end of line
> 'x' '\'' 'x
< Q-- Q--- W-.

// Character literal, with joiner (unlikely)
> '\
< Q-.
> x'
< Q-.

// String literals, including unclosed
> "hello world" "a\"b" "unclosed
< Q----- Q----- Q----- W--------.

// String literal with joiner
> "hello \
< Q----- Q.
> world"
< Q-----.

// One line comment
> n = 0; // note
< I O VS N- N---.

// One line comment with joiner.
> n = 0; // note \
< I O VS N- N--- N.
> n = 1;
< N N N-.

// Multi-line comment
> n = 0; /* line one
< I O VS C- C--- C--.
> line two */ n = 1;
< C--- C-- C- I O VS.

// Numbers
> 42 1.2e+3 4.5E-6 0x7f 0x7F 0x7c.def 0xa.bcp+d 0xaU 0xaL 
< V- V----- V----- V--- V--- V------- V-------- V--- V---.

// Reserved words (there can be spaces between # and a reserved word)
> #if # else #define #include
< MM- M M--- MM----- MM------.

// Include filename
> #include <f> #include <one two.ext>
< MM------ Q-- MM------ Q--- Q-------.

// Joiner
> #define f(x) \
< MM----- ILIR J.

// Illegal characters
> $ @ `
< W W W.

// Leading spaces
>    x
<    I.

// A few general tests

> if (b) n = 1;
< K- LIR I O VS.

> if (b) { n = 1; }
< K- LIR B I O VS E.

> int n;
< T-- IS.

> string s;
< I----- IS.

> enum suit { Club, Diamond, Heart, Spade };
< K--- I--- L I---S I------S I----S I---- ES.

> int ns[] = { 1, 2, 34};
< T-- I-LR O L VS VS V-ES.

> char *s = "a\nb\0c\04d";
< T--- OI O Q------------S.

> char *s = "\037e\038f\xffg";
< T--- OI O Q----------------S.

> s = "*/"//"; /* abc "*/"//";
< I O Q---N-N- N- N-- N-------.

> /*  "*/"//"; /* abc "*/"//";
< C-  C--Q---S C- C-- C--Q---S.

> obj.x, obj->x, f(x)
< I--OIS I--S-IS ILIR.

> n = f   (x);
< I O I   LIRS.
