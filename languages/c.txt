// C language definition, based on the C11 standard.

// It is assumed that there are no digraphs or trigraphs (or that they are
// handled by some form of preprocessing). Line joiners (i.e. backslash before
// newline) are assumed to occur only between tokens (e.g. in #define) or
// in strings (even though concatenation of adjacent strings can be used).

// -----------------------------------------------------------------------------

// Keywords which are types or related to types. Include bool from <stdbool.h>.
// The type state checks for added characters which make the token an id.

start   _Atomic _Bool _Complex _Generic _Imaginary      type
start   bool char double float int long                 type
start   short signed unsigned void                      type
type    a..z A..Z 0..9 _ \\U \\u                        id
type    \                                               start Decl

// Other keywords. Include false, true from <stdbool.h>. The key states check
// for added characters. The enum and struct keywords cause bracket checking.

start   _Alignas _Noreturn _Static_assert _Thread_Local         key
start   alignof auto break case const continue default do else  key
start   extern false for goto if inline register restrict       key
start   return sizeof static switch true typedef union          key
start   volatile while                                          key
start   enum struct                                             key1
key     a..z A..Z 0..9 _ \\U \\u                                id
key     \                                                       start Key
key1    a..z A..Z 0..9 _ \\U \\u                                id
key1    \                                                       decl Key

// Identifiers

start   a..z A..Z _ \\U \\u        id
id      a..z A..Z 0..9 _ \\U \\u   id
id      \                          start Id

// Operators and signs. A + or - is marked infix, even though it can be prefix,
// because it is far more likely to indicate a continuation line than to be the
// start of a statement.

start   ++ -- ! ~                                   start Unary
start   != %= % && &= & *= * += + -= - /= / ?       start Op
start   <<= << <= < == >= >>= >> > ^= ^ |= || |     start Op
start   ## , ; : -> ...                             start Mark
start   =                                           init  Op

// Brackets. By default { and } are block brackets. To help with semicolon
// insertion, the opener { is marked as a group bracket instead, by the
// rules below. The closer } is marked as a group bracket to match.

start  {   start BlockB
start  }   start BlockE
start  [   start SquareB
start  ]   start SquareE
start  (   start RoundB
start  )   start RoundE

// Check for declaration brackets  enum {  or  struct {
decl   {                           start GroupB
decl   a..z A..Z _ \\U \\u         decl1
decl   \s \n                       decl
decl   \                           start

// Check for  enum ID  or  struct ID
decl1   a..z A..Z 0..9 _ \\U \\u   decl1
decl1   \                          decl2 Id

// Check for  enum ID {  or  struct ID {
decl2   {                          start GroupB
decl2   \s \n                      decl2
decl2   \                          start

// Check for initialiser brackets  = {
init    {                          start GroupB
init    (                          init1 Round2B
init    \s \n                      init
init    \                          start

// Check for   = (   or   = (struct
init1   struct                     init1 Key
init1   a..z A..Z _ \\U \\u        init2
init1   \s \n                      init1
init1   \                          start

// Check for   = (ID   or   = (struct ID
init2   a..z A..Z 0..9 _ \\U \\u   init2
init2   \                          init3 Id

// Check for   = (ID)   or   = (struct ID)
init3   )                          init4 Round2E
init3   \s \n                      init3
init3   \                          start

// Check for   = (ID) {   or   = (struct ID) {
init4   {                          start GroupB
init4   \                          start

// A dot starts a number, or is an operator.

start   .      dot
dot     \0..9  decimal
dot     \      start Op

// Character literals.

start   '      char QuoteB
char    !..~   char
char    \\'    char
char    \s     char Quote
char    '      start QuoteE
char    \n     start Quote

// String literals. Allow joiners

start     "      string QuoteB
string    !..~   string
string    \\"    string
string    \\\    string2 Quote
string    \s     string Quote
string    "      start QuoteE
string    \n     start Quote

string2   \\     string3
string2   \      string
string3   \n     start Join
string3   \s     string Quote
string3   \      string

// One-line comment.

start    abc    fred
fred     )      start BlockE
fred     )      start GroupE
fred     \      start Note

start    //     note NoteB
note     !..~   note
note     \s     note Note
note     \n     start Note

// Multi-line comment.

start    /*     start CommentB
start    */     start CommentE

// Numbers. There is no attempt to detect malformed numbers.
start    0..9           decimal
start    0x 0X          hex
decimal  0..9 .         decimal
decimal  e+ e- E+ E-    decimal
decimal  u U l L ll LL  decimal
decimal  \              start Value
hex      0..9 .         hex
hex      a..f A..F      hex
hex      p+ p- P+ P-    hex
hex      u U l L ll LL  hex
hex      \              start Value

// Reserved words. Preprocessor tokens are handled as normal tokens, except for
// <filename> after #include.

start     #                                 hash Alt
hash      \s                                hash
hash      include                           include Alt
hash      define elif else endif error if   start Alt
hash      ifdef ifndef line pragma undef    start Alt
hash      \                                 start

include   <                                 filename QuoteB
include   \s                                include
include   \                                 start

filename  !..~                              filename
filename  >                                 start QuoteE
filename  \s                                filename Quote
filename  \n                                start Quote

// Backslash newline, e.g. in #define

start \\ start Join

// Illegal characters and white space.
start     $ @ `   start Wrong
start     \s \n   start

// ---------- Tests ------------------------------------------------------------
// In the expected output for a test, the start of each token is marked by the
// first letter of its type. Remaining characters are marked with space, a
// space is marked with an underline, and a newline is marked with a dot.

// A few tokens
> (count+1)
< LI----OVR.

// An id can start with a type or keyword
> char chart for form
< T--- I---- K-- I---.

// Operators and signs of different fixities
> ++!<<=...->
< U-UO--M--S-.

// Structure and block brackets (left structure bracket marked L)
> s={}; do{}
< IOLES K-BE.

// More left structure brackets
> enum{  struct{  enum E{  struct S{
< K---L  K-----L  K--- IL  K----- IL.

// More left structure brackets
> ={ =(t){ =(struct t){
< OL OLIRL OLK----- IRL.

// Dot as sign or as part of number
> s.x 1.2 .2
< IOI V-- V-.

// Character literals, including unclosed at end of line
> 'x' '\'' 'x
< Q-- Q--- W-.

// Character literal, with joiner (unlikely)
> '\
< Q-.
> x'
< Q-.

// String literals, including unclosed
> "hello world" "a\"b" "unclosed
< Q----- Q----- Q----- W--------.

// String literal with joiner
> "hello \
< Q----- Q.
> world"
< Q-----.

// One line comment
> n = 0; // note
< I O VS N- N---.

// One line comment with joiner.
> n = 0; // note \
< I O VS N- N--- N.
> n = 1;
< N N N-.

// Multi-line comment
> n = 0; /* line one
< I O VS C- C--- C--.
> line two */ n = 1;
< C--- C-- C- I O VS.

// Numbers
> 42 1.2e+3 4.5E-6 0x7f 0x7F 0x7c.def 0xa.bcp+d 0xaU 0xaL 
< V- V----- V----- V--- V--- V------- V-------- V--- V---.

// Reserved words (there can be spaces between # and a reserved word)
> #if # else #define #include
< MM- M M--- MM----- MM------.

// Include filename
> #include <f> #include <one two.ext>
< MM------ Q-- MM------ Q--- Q-------.

// Joiner
> #define f(x) \
< MM----- ILIR J.

// Illegal characters
> $ @ `
< W W W.

// Leading spaces
>    x
<    I.

// A few general tests

> if (b) n = 1;
< K- LIR I O VS.

> if (b) { n = 1; }
< K- LIR B I O VS E.

> int n;
< T-- IS.

> string s;
< I----- IS.

> enum suit { Club, Diamond, Heart, Spade };
< K--- I--- L I---S I------S I----S I---- ES.

> int ns[] = { 1, 2, 34};
< T-- I-LR O L VS VS V-ES.

> char *s = "a\nb\0c\04d";
< T--- OI O Q------------S.

> char *s = "\037e\038f\xffg";
< T--- OI O Q----------------S.

> s = "*/"//"; /* abc "*/"//";
< I O Q---N-N- N- N-- N-------.

> /*  "*/"//"; /* abc "*/"//";
< C-  C--Q---S C- C-- C--Q---S.

> obj.x, obj->x, f(x)
< I--OIS I--S-IS ILIR.

> n = f   (x);
< I O I   LIRS.
