# TODO: bracket matcher needs to recognize BAD, DELIMITER (QUOTED/LIT, COMMENT)
# Maybe declare brackets/delimiters ( )  [ ]  { }  "..." '...' //...$ /*...*/
# Maybe declare ( ) [ ] { } -> BAD1  ".." '..' -> BAD2 //..$ /*..*/ -> BAD3
# Maybe openers to left of table, closers on top.

# C language scanner, according to the C11 standard
# See http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf
# Compile to c.bin and copy that to h.bin.

# Potential keywords: go to key state to check if really identifiers
start  _Alignas _Atomic _Bool _Complex _Generic _Imaginary _Noreturn    key
start  _Static_assert _Thread_Local alignof auto bool break case char   key
start  const continue default do double else enum extern false float    key
start  for goto if inline int long register restrict return short       key
start  signed sizeof static struct switch true typedef union unsigned   key
start  void volatile while                                              key

# Operators
start != ! % && &= & *= * ++ += + -- -= - /= /  start OP
start <<= << <= < == >= >>= >> > ^= ^ |= || | ~ start OP

# Symbols - an arrow may be followed by a field
start ## %:%: %= , ... = : ; ?? ? start SYM
start ( ) [ <: ] :> { <% } %> start SYM
start -> field SYM

# Identifiers, numbers, preprocessor lines
start a..z A..Z _ \U \u id
start 0..9 num
start . dot
start # %: hash RESERVED

# Quotes, escape sequences, comments, white space, illegal characters
start ' " start QUOTED
start \ escape
start /* */ // start COMMENT
start start INVALID

# Potential keywords, if not followed by alphanumerics.
key a..z A..Z 0..9 _ \U \u id
key start KEY

# Identifiers
id a..z A..Z 0..9 _ \U \u id
id start ID

# A dot starts a number, or is a symbol possibly followed by a field.
dot 0..9 num
dot field SYM

# A field is an identifier following a dot or arrow
field a..z A..Z 0..9 _ \U \u field
field start FIELD

# Numbers with possible exponents.
num . 0..9 num
num e+ e- E+ E- num
num p+ p- P+ P- num
num start N

# Escape sequences: single character, hex, octal
escape a..w y..z start ESCAPE
escape x escapex
escape 0..7 escape1
escape start INVALID

# Octal escape sequences: up to three digits.
escape1 0..7 escape2
escape1 start ESCAPE
escape2 0..7 start ESCAPE
escape2 start ESCAPE

# Hex escape sequences: any number of digits
escapex 0..9 a..f A..F escapex
escapex start ESCAPE

# A hash is followed by a preprocessor keyword.
hash include inclusion RESERVED
hash define elif else endif error if start RESERVED
hash ifdef ifndef line pragma undef start RESERVED
hash start RESERVED

# After #include, aim to scan <filename> as a string.
inclusion < file QUOTED
inclusion start QUOTED
file !..= ?..~ file
file > start QUOTED
file start QUOTED

-------------------------------------------------------------------------------
abc
abc I

(def)
( S def I ) S

if (b) n = 1;
if K ( S b I ) S n I = S 1 N ; S

if (b) { n = 1; }
if K ( S b I ) S { S n I = S 1 N ; S } S

int n;
int K n N ; S

string s;
string I s I ; S

enum suit { Club, Diamond, Heart, Spade };
enum K suit I { S Club I , S Diamond I , S Heart I , S Spade I } S ; S

int ns[] = { 1, 2, 34};
int K ns I [ S ] S = S { S 1 N , S 2 N , S 34 N } S ; S

char *s = "a\nb\0c\04d";
char K * S s I = S " Q a I \n E b I \0 E c I \04 E d I " Q

char *s = "\037e\038f\xffg"
char K * S s I = S " Q \037 E e I \03 E 8 N f I \xff E g I " Q

/* abc "*/"//"
/* C abc I " Q */ C " I // C " Q

obj.x, obj->x, f(x)
obj I . S x I , S obj I -> S x I , C f F ( S x I ) S

#include <stdio.h>
# R include R <stdio.h> Q
