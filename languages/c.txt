// C language definition, based on the C11 standard.

// Keywords which are types or related to types. Include bool from <stdbool.h>.
// The type state checks for added characters which make the token an id.

start   _Atomic _Bool _Complex _Generic _Imaginary      type
start   bool char double float int long                 type
start   short signed unsigned void                      type
type    a..z A..Z 0..9 _ \\U \\u                        id
type    \                                               start TYPE

// Other keywords. Include false, true from <stdbool.h>. The key states check
// for added characters. The enum and struct keywords cause bracket checking.

start   _Alignas _Noreturn _Static_assert _Thread_Local         key
start   alignof auto break case const continue default do else  key
start   extern false for goto if inline register restrict       key
start   return sizeof static switch true typedef union          key
start   volatile while                                          key
start   enum struct                                             key1
key     a..z A..Z 0..9 _ \\U \\u                                id
key     \                                                       start KEY
key1    a..z A..Z 0..9 _ \\U \\u                                id
key1    \                                                       decl KEY

// Identifiers

start   a..z A..Z _ \\U \\u        id
id      a..z A..Z 0..9 _ \\U \\u   id
id      \                          start ID

// Operators and signs. A + or - is marked infix, and a ++ or -- is marked
// nonfix, for semicolon insertion, on the assumption that when it has one
// operand, it won't be separated by a newline from the operand.

start   ++ -- ! ~                                   start UNARY
start   != %= % && &= & *= * += + -= - /= / ?       start OP
start   <<= << <= < == >= >>= >> > ^= ^ |= || |     start OP
start   ...                                         start MARK
start   ## , ; : ->                                 start SIGN
start   =                                           init  OP

// Brackets. By default { and } are block brackets. To help with semicolon
// insertion, the opener { is marked as an inline bracket LEFT instead, by the
// rules below. The closer } is changed from END to RIGHT to match by Snipe
// during bracket matching.

start  {   start BEGIN
start  }   start END
start  [   start LEFT
start  ]   start RIGHT
start  (   start LEFT
start  )   start RIGHT

// Check for declaration brackets  enum {  or  struct {
decl   {                           start LEFT
decl   a..z A..Z _ \\U \\u         decl1
decl   \s \n                       decl
decl   \                           start

// Check for  enum ID  or  struct ID
decl1   a..z A..Z 0..9 _ \\U \\u   decl1
decl1   \                          decl2 ID

// Check for  enum ID {  or  struct ID {
decl2   {                          start LEFT
decl2   \s \n                      decl2
decl2   \                          start

// Check for initialiser brackets  = {
init    {                          start LEFT
init    (                          init1 LEFT
init    \s \n                      init
init    \                          start

// Check for   = (   or   = (struct
init1   struct                     init1 KEY
init1   a..z A..Z _ \\U \\u        init2
init1   \s \n                      init1
init1   \                          start

// Check for   = (ID   or   = (struct ID
init2   a..z A..Z 0..9 _ \\U \\u   init2
init2   \                          init3 ID

// Check for   = (ID)   or   = (struct ID)
init3   )                          init4 RIGHT
init3   \s \n                      init3
init3   \                          start

// Check for   = (ID) {   or   = (struct ID) {
init4   {                          start LEFT
init4   \                          start

// A dot starts a number, or is an operator.

start   .      dot
dot     \0..9  decimal
dot     \      start OP

// Character literals. Allow joiners

start   '      char1
char    !..~   char1
char    \\     char2
char    \s     char
char    '      start QUOTE
char    \n     start

// After '
char1   !..~   char1
char1   \\     char2
char1   \s     char QUOTE
char1   '      start QUOTE
char1   \n     start WRONG

// After '...\
char2   \n \s  char3 QUOTE
char2   ' \    char1

// After '...\ with a newline next
char3   \n \   char

// String literals. Allow joiners

start     "      string1
string    !..~   string1
string    \\     string2
string    \s     string
string    "      start QUOTE
string    \n     start

// After "
string1   !..~   string1
string1   \\     string2
string1   \s     string QUOTE
string1   "      start QUOTE
string1   \n     start WRONG

// After "...\
string2   \n \s  string3 QUOTE
string2   " \    string1

// After "...\ with a newline next
string3   \n \   string

// One-line comment. Allow joiner.

start    //     note NOTE
note     !..~   note1
note     \\     note2
note     \s     note
note     \n     start
note1    !..~   note1
note1    \\     note2
note1    \s \n  note NOTE
note2    \n \s  note3 NOTE
note2    \      note1
note3    \n \   note

// Multi-line comment. Allow joiner.

start      /*         comment COMMENT
comment    !..~       comment1
comment    \\         comment2
comment    \s \n      comment
comment    */         start COMMENT
comment1   !..~       comment1
comment1   \\         comment2
comment1   \s \n      comment COMMENT
comment1   */         start COMMENT
comment2   \n \s      comment3 COMMENT
comment2   \          comment1
comment3   \n \       comment

// Numbers. There is no attempt to detect malformed numbers.
start    0..9           decimal
start    0x 0X          hex
decimal  0..9 .         decimal
decimal  e+ e- E+ E-    decimal
decimal  u U l L ll LL  decimal
decimal  \              start VALUE
hex      0..9 .         hex
hex      a..f A..F      hex
hex      p+ p- P+ P-    hex
hex      u U l L ll LL  hex
hex      \              start VALUE

// Reserved words. Preprocessor tokens are handled as normal tokens, except for
// <filename> after #include.

start     #                                 hash MARK
hash      \s                                hash
hash      include                           include MARK
hash      define elif else endif error if   start MARK
hash      ifdef ifndef line pragma undef    start MARK
hash      \                                 start

include   <                                 filename0 QUOTE
include   \s                                include
include   \                                 start

filename0  !..~                             filename1
filename0  >                                start QUOTE
filename0  \s                               filename0
filename0  \n                               start

filename1  !..~                             filename1
filename1  \> \s                            filename0 QUOTE
filename1  \n                               start WRONG

// Backslash newline is only supported between tokens (only needed for #define)

start \\ start JOIN

// Illegal characters and white space.
start     $ @ `   start WRONG
start     \s \n   start

// ---------- Tests ------------------------------------------------------------
// In the expected output for a test, the start of each token is marked by the
// first letter of its type. Remaining characters are marked with space, a
// space is marked with an underline, and a newline is marked with a dot.

// A few tokens
> (count+1)
< LI    OVR.

// An id can start with a type or keyword
> char chart for form
< T   _I    _K  _I   .

// Operators and signs of different fixities
> ++!<<=...->
< U UO  M  S .

// Structure and block brackets (left structure bracket marked L)
> s={}; do{}
< IOLES_K BE.

// More left structure brackets
> enum{  struct{  enum E{  struct S{
< K   L__K     L__K   _IL__K     _IL.

// More left structure brackets
> ={ =(t){ =(struct t){
< OL_OLIRL_OLK     _IRL.

// Dot as sign or as part of number
> s.x 1.2 .2
< IOI_V  _V .

// Character literals, including unclosed at end of line
> 'x' '\'' 'x
< Q  _Q   _W .

// Character literal, with joiner (unlikely)
> '\
< Q .
> x'
< Q .

// String literals, including unclosed
> "hello world" "a\"b" "unclosed
< Q     _Q     _Q     _W        .

// String literal with joiner
> "hello \
< Q     _Q.
> world"
< Q     .

// One line comment
> n = 0; // note
< I_O_VS_N _N   .

// One line comment with joiner.
> n = 0; // note \
< I_O_VS_N _N   _N.
> n = 1;
< N_N_N .

// Multi-line comment
> n = 0; /* line one
< I_O_VS_C _C   _C  .
> line two */ n = 1;
< C   _C  _C _I_O_VS.

// Numbers
> 42 1.2e+3 4.5E-6 0x7f 0x7F 0x7c.def 0xa.bcp+d 0xaU 0xaL 
< V _V     _V     _V   _V   _V       _V        _V   _V   .

// Reserved words (there can be spaces between # and a reserved word)
> #if # else #define #include
< MM _M_M   _MM     _MM      .

// Include filename
> #include <f> #include <one two.ext>
< MM      _QQQ_MM      _QQ  _Q      Q.

// Joiner
> #define f(x) \
< MM     _ILIR_J.

// Illegal characters
> $ @ `
< W_W_W.

// Leading spaces
>    x
< ___I.

// A few general tests

> if (b) n = 1;
< K _LIR_I_O_VS.

> if (b) { n = 1; }
< K _LIR_B_I_O_VS_E.

> int n;
< T  _IS.

> string s;
< I     _IS.

> enum suit { Club, Diamond, Heart, Spade };
< K   _I   _L_I   S_I      S_I    S_I    _ES.

> int ns[] = { 1, 2, 34};
< T  _I LR_O_L_VS_VS_V ES.

> char *s = "a\nb\0c\04d";
< T   _OI_O_Q            S.

> char *s = "\037e\038f\xffg";
< T   _OI_O_Q                S.

> s = "*/"//"; /* abc "*/"//";
< I_O_Q   N N _N _N  _N       .

> /*  "*/"//"; /* abc "*/"//";
< C __C  Q   S_C _C  _C  Q   S.

> obj.x, obj->x, f(x)
< I  OIS_I  S IS_ILIR.

> n = f   (x);
< I_O_I___LIRS.
