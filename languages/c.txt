// C language definition, based on the C11 standard
// See http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf
// The source text is assumed to be normalised, with no control characters
// other than \n and no digraphs or trigraphs.
// Backslash newline is only supported between tokens or in string literals.
// A few ids such as bool, false, true from <stdbool.h> are treated as keywords.

// =============================================================================
// Scanning rules for C. Each rule is a state (with : suffix, no spaces)
// patterns and a tag or state or both (with : prefix, no spaces). A colon as a
// pattern must be on its own. A tag on its own implies 'start' (first state) as
// target. A \ on its own matches a backslash. A \ prefix means lookahead,
// except \ on its own or \\ means actual backslash. \n means newline lookahead,
// \s means space lookahead, neither can be matched and included in a token.
// Gaps and newlines are automatically tagged with special (anonymous) tags.

// Keywords which are types or related to types. The type state checks for
// additional characters which mean the token is an id.
start:   _Atomic _Bool _Complex _Generic _Imaginary      :type
start:   bool char double float int long                 :type
start:   short signed unsigned void                      :type
type:    a..z A..Z 0..9 _ \\U \\u                        :id
type:                                                    :TYPE

// Other keywords. The key state checks for additional characters.
start:   _Alignas _Noreturn _Static_assert _Thread_Local         :key
start:   alignof auto break case const continue default do else  :key
start:   enum extern false for goto if inline register restrict  :key
start:   return sizeof static struct switch true typedef union   :key
start:   volatile while                                          :key
key:     a..z A..Z 0..9 _ \\U \\u                                :id
key:                                                             :KEY

// Operators and signs.
start:   != ! % && &= & *= * ++ += + -- -= - /= / ?  :OP
start:   <<= << <= < == >= >>= >> > ^= ^ |= || | ~   :OP
start:   ## %= , ... ; : -> =                        :SIGN

// Identifiers
start:   a..z A..Z _ \\U \\u        :id
id:      a..z A..Z 0..9 _ \\U \\u   :id
id:                                 :ID

// Brackets. The defaults for { and } are block brackets. They are adjusted to
// COPEN, CCLOSE for declaration or initialiser brackets. Multi-line comment
// delimiters are handled as brackets.
start:  (   :ROPEN
start:  )   :RCLOSE
start:  [   :SOPEN
start:  ]   :SCLOSE
start:  {   :BOPEN
start:  }   :BCLOSE
start:  /*  :MOPEN
start:  */  :MCLOSE

// A dot starts a number, or is a sign.
start:   .           :dot
dot:     \0..9       :float
dot:                 :SIGN

// Quotes and delimiters. Content handled later by context.
start:  #   :RESERVED
start:  '   :QUOTE
start:  "   :QUOTES
start:  //  :NOTE

// Escapes. A backslash newline (line joiner) doesn't include the newline.
start:   \     :escape
escape:  a b f n r t v ' " \  :ESCAPE
escape:  0..7  :oescape1
escape:  x     :hescape
escape:  u     :ushort
escape:  U     :ulong
escape:  !..~  :BAD
escape:  \n    :JOIN
escape:        :BAD

oescape1:  0..7  :oescape2
oescape1:        :ESCAPE
oescape2:  0..7  :ESCAPE
oescape2:        :ESCAPE

hescape:  0..9 A..F a..f  :hescape
hescape:                  :ESCAPE

ushort:   0..9 A..F a..f  :ushort1
ushort:                   :BAD
ushort1:  0..9 A..F a..f  :ushort2
ushort1:                  :BAD
ushort2:  0..9 A..F a..f  :ushort3
ushort2:                  :BAD
ushort3:  0..9 A..F a..f  :ESCAPE
ushort3:                  :BAD

ulong:   0..9 A..F a..f  :ulong1
ulong:                   :BAD
ulong1:  0..9 A..F a..f  :ulong2
ulong1:                  :BAD
ulong2:  0..9 A..F a..f  :ulong3
ulong2:                  :BAD
ulong3:  0..9 A..F a..f  :ulong4
ulong3:                  :BAD
ulong4:  0..9 A..F a..f  :ulong5
ulong4:                  :BAD
ulong5:  0..9 A..F a..f  :ulong6
ulong5:                  :BAD
ulong6:  0..9 A..F a..f  :ulong7
ulong6:                  :BAD
ulong7:  0..9 A..F a..f  :ESCAPE
ulong7:                  :BAD

// An illegal character is a one-character error token
start: !..~ :BAD
start:      :start

// Numbers with possible exponents.
start:   \0..9  :number
number:  0x 0X  :hex
number:  0      :octal

octal:   0..7   :octal
octal:   8..9   :octalfloat
octal:          :VALUE

octalfloat:  0..9   :octalfloat
octalfloat:  .      :float
octalfloat:         :BAD





// Numbers with possible exponents. TODO check
start:   0..9          :num
num:     . 0..9        :num
num:     e+ e- E+ E-   :num
num:     p+ p- P+ P-   :num
num:                   :VALUE

constant =
    integer-constant @1constant /
    floating-constant @1constant /
-- Look ahead to see if a number is floating or not
is-float = "0x" ('.' / hexadecimal-digit+ '.pP') / ('.' / digit+ '.eE')
integer-constant =
    hexadecimal-constant integer-suffix? /
    octal-constant integer-suffix? /
    decimal-constant integer-suffix?
decimal-constant = nonzero-digit digit*
octal-constant = '0' octal-digit*
hexadecimal-constant = hexadecimal-prefix hexadecimal-digit+
hexadecimal-prefix = "0x" / "0X"
nonzero-digit = '123456789'
octal-digit = '01234567'
hexadecimal-digit = '0123456789abcdefABCDEF'
integer-suffix =
    unsigned-suffix (long-long-suffix / long-suffix)? /
    long-long-suffix unsigned-suffix? /
    long-suffix unsigned-suffix?
unsigned-suffix = 'uU'
long-suffix = 'lL'
long-long-suffix = "ll" / "LL"
floating-constant =
    hexadecimal-floating-constant /
    decimal-floating-constant
decimal-floating-constant =
    '.' digit-sequence exponent-part? floating-suffix? /
    digit-sequence ('.' digit-sequence?)? exponent-part? floating-suffix?
hexadecimal-floating-constant = hexadecimal-prefix hex-part1 hex-part2
hex-part1 =
    '.' hexadecimal-digit-sequence /
    hexadecimal-digit-sequence ('.' hexadecimal-digit-sequence?)?
hex-part2 = binary-exponent-part floating-suffix?
-- Fractional constants have been absorbed into the above rules.
exponent-part = 'eE' sign? digit-sequence
sign = '+-'
digit-sequence = digit+
binary-exponent-part = 'pP' sign? digit-sequence
-- Hexadecimal fractional constants have been absorbed into the above rules.
-- Binary exponent parts have been absorbed into the above rules.
hexadecimal-digit-sequence = hexadecimal-digit+
floating-suffix = 'flFL'

// TODO reserved words (IdReserved->Id or KeyReserved->Key)
// TODO how can this be made context-free?
// (answer, handle it in the next pass)
hash      include                           include RESERVED
hash      define elif else endif error if   start RESERVED
hash      ifdef ifndef line pragma undef    start RESERVED
hash+     ..                                start

// TODO: handle via context pass
include   <                                 filename
include   ..                                start +
filename  >                                 start QUOTED
filename  \n                                start BAD+
filename  ..                                filename

// TODO: escapes, and rest via context/matching
char    \'  char
char    '   QUOTED
char    ..  char
char        BAD

// TODO: rest via escapes and context/matching
string+     \s \b\n  stringGap QUOTED
string+     /* */    stringBad QUOTED
string+     \n       start BAD
string      \"       string
string      "        start QUOTED
string      ..       string
stringGap   \s \b\n  string GAP xxx
stringGap+  ..       string GAP
stringBad   /* */    string BAD
stringGap+  ..       string BAD

// One-line comment. Mark /* or */ as warning.
start    //     note
note     \n     start COMMENT+
note     /* */  noteBad
note     ..     note
noteBad  /* */  note BAD
noteBad+ ..     note BAD

// Multi-line comment.
// TODO: handle by bracketing
start /* comment
comment \s       commentGap COMMENT+
comment \n commentGap COMMENT
comment */ start COMMENT
comment .. comment
commentGap \s       commentGap
commentGap .. comment COMMENT


// =============================================================================
// Context rules. Distinguished by starting with upper case letter.
// state: tags or patterns or lookahead :tag state
// colon special, must appear on own, no real problem.
// backslash special, must appear on own, no real problem.

Start: - :InOp Right           // seems OK
Char: \n :Bad Start            // apply tag to lookahead is special
                               // maybe insert zero-length bad token



// On edit, widen the range leftward by the max lookahead, and rightward by the
// max lookback. Then re-scan should be straightforward.

ID   ->   PROPERTY
ID   .    PROPERTY

// To help support automatic semicolon handling, mark an open curly bracket
// either as OPENb (for blocks) or OPENi (for initialisers etc.).  Catch the
// most common contexts.

start: { :start Enum OpenC
start: { :start Enum Id OpenC
start: { :start Struct OpenC
start: { :start Struct Id OpenC
start: { :start OpenB

OPENb   enum              OPENi
OPENb   enum ID           OPENi
OPENb   struct            OPENi
OPENb   struct ID         OPENi
OPENb   =                 OPENi
OPENb   = ( ID )          OPENi
OPENb   = ( struct ID )   OPENi

// =============================================================================
// Fixity of each tag, for semicolon insertion.

$infix  OPENb CLOSEb
$prefix CLOSEi

// =============================================================================
// Bracket rules. Distinguished by = < > ! ? symbols. Rules starting with an
// opener are relevant to the forward algorithm. Rules starting with a closer
// are relevant to the backward algorithm.

// Match rules.
// Establish the bracket tags, which are openers, which closers, and which match
OpenRound = CloseRound
OpenSquare = CloseSquare
OpenCurly = CloseBlock <-> CloseCurly  // OCB has become OC, non-block
OpenBlock = CloseBlock    // transfer the info, back and forth
OpenComment = CloseComment

// Mismatch rules
OpenRound < CloseSquare   // < means mark opener as mismatched and pair up
OpenRound < CloseCurly
OpenRound < CloseBlock
OpenSquare < CloseCurly
OpenSquare < CloseBlock
OpenSquare > CloseRound   // > means mark closer as mismatched and pair up
OpenCurly > CloseSquare
OpenCurly > CloseRound
OpenBlock > CloseSquare
OpenBlock > CloseRound

// TODO: OpenRound `consumes/ignores` any
OpenRound + $
$ + CloseRound

// By default, any open followed by any open means push
// By default, closer-closer rules are symmetrical.
OpenRound < OpenSquare
...

// For comments, mark all following tokens as comments (or errors)
// TODO: implement by adding and removing a flag
OpenComment + OpenComment <-> BadComment
OpenComment + KEY <-> CKEY
...

// =============================================================================
// Theme mappings, distinguished by #
// Theme tags are COMMENTED, BAD, FUNCTION, ID, KEY, OP, PROPERTY, QUOTED,
// RESERVED, SIGN, TYPE, VALUE

#SIGN OpenRound CloseRound ...

// Maybe single-letter mappings for tests. Maybe same as theme.
// What do tests look like now?
// Distinguished by single letter start.
I Id

// =============================================================================
// Maybe tests included (again!)
