<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" xml:lang="en-GB">
<head>
<meta charset="UTF-8"/>
<style>
    body { font-size: 120%; }
    pre, .indent { margin-left: 40px; }
    img { display: block; margin: 0 auto; }
    mark {
      font-family: cursive;
      font-size: 95%;
      color: #080;
      background-color: white;
    }
</style>
<title>Snipe Customisation</title>
</head>
<body>

<h1>Customisation</h1>

<p>To customise <mark>Snipe</mark>, edit the file <code>settings.txt</code> in
the installation directory, and restart the editor. The possibilities for the
settings are described in the source file <a href="setting.h">setting.h</a></p>

<h2>Fonts</h2>

<p>The default font and nominal pixel size are defined in the
<code>settings.txt</code> file. The font file must be in <code>.ttf</code>
format. At present, only ASCII text is supported.</p>

<p>The only font currently provided is <code>DejaVuSansMono</code>, which
supports a fairly wide range of national languages within a single font file,
though it doesn't support ideographic languages.</p>

<h2>Maps</h2>

<p>The mapping from events, i.e. key presses and mouse clicks etc., to editor
actions is defined in a file specified by <code>settings.txt</code>. To
customise, edit the map file or a copy of it, and restart the editor.</p>

<p>Each line of a map file consists of the name of an event followed by the name
of an action. To find the available events and actions, see the
<a href="event.h">event.h</a> and <a href="action.h">action.h</a> source
files.</p>

<h2>Themes</h2>

<p>The <code>settings.txt</code> file lists the file paths for themes, and the
editor cycles through them with C_Enter.</p>

<p>Your choice of theme may depend on the ambient light level, your eyesight,
your chosen font and size, the colour quality of your screen, or your taste. The
default themes provided are <a
href="https://github.com/altercation/solarized">solarized-dark and
solarized-light</a>, which are designed to have low to medium contrast, to be
restful on the eye over long periods of time with indoor lighting, and to match
each other so that it is comfortable to switch between them. Other themes may be
provided, e.g. with higher contrast, which can be used instead or as well.</p>

<p>You can construct your own theme file, perhaps based on information from <a
href="https://github.com/highlightjs/highlight.js/tree/master/src/styles"
>highlight.js</a> or elsewhere. If a line of a theme file is blank or starts
with <code>//</code> it is a comment. Otherwise, it consists of a sequence of
one-character token tags, followed by a hash character and hex RGB colour value,
followed by a comment, all separated by one or more spaces. The colour for a gap
(tag <code>_</code>) is the general background colour. Three extra characters
are allowed besides token tags, <code>|</code> for the colour of a cursor,
<code>!</code> for the background colour of a selection and <code>@</code> for
the background colour of an invalid token or mismatched bracket. Each style is
used for a token type or similar. For the available styles, see the <a
href="style.h">style.h</a> source file.</p>

<h2>Language descriptions</h2>

<p><mark>Snipe</mark> has a scanner used to divide the text of a file being
edited into tokens, and to tag each token with a type. The scanner has different
goals from those of a scanner in a compiler. On the one hand, it may omit some
details needed only for full compiling, it may accept some tokens that a
compiler would reject, it may classify tokens differently, and it may not need
to be completely accurate. On the other hand, it must tag all characters
including white space and comments, it must be able to handle any text whether
valid or not, and it must produce tags which are suitable to drive syntax
highlighting, word-based cursor movement, auto indenting, continuations,
wrapping and so on.</p>

<p>A language is described by a file in the <kbd>languages/src</kbd> directory.
For example, <code>c.txt</code> defines the syntax of <code>.c</code> files.
Each file is a description of a string-matching state machine for scanning text
in the given language, together with tests which demonstrate the effects.</p>

<p>Sometimes there are multiple interpretations of program text. In C, for
example, <code>"*/"//"</code> would normally be interpreted as a string literal
<code>"*/"</code> followed by a one-line comment <code>//"</code>. The situation
can be pictured with a line below the text containing a tag at the start of each
token to classify it.</p>

<pre>"*/"//"
"   #
</pre>

<p>However, if the text <code>"*/"//"</code> appears inside a multiline comment,
<code>"*/</code> is interpreted as the last part of the comment, and
<code>"//"</code> as a string literal :</p>

<pre>
/*..."*/"//"
&lt;       "
</pre>

<p>There is a way to avoid these problems, and to scan text in a context free
way, so that it never needs to be rescanned. After an edit, only the new text
needs to be scanned, so scanning becomes incremental. To achieve this, compounds
such as comments or string literals are divided by the scanner into smaller
tokens than usual. Thus the line <code>"*/"//"</code> is scanned once and for
all into the five tokens <code>" */ " // "</code>, with the first middle and
last tagged as string quotes, the second as an end of comment, and the fourth as
a start of one-line comment:</p>

<pre>"*/"//"
"> "# "
</pre>

<p>With this approach, there are no long tokens. These small tokens work well
inside comments, to support such things as word-based cursor movement and
wrapping. In the editor, bracket matching is used to match quotes or the start
and end of comments, and adjust token types for display. This avoids the
rescanning delays in some editors when open comment or close comment symbols are
typed.</p>

<p>The format of language description files is fairly simple. A line which is
blank or starts with a non-letter such as <code>#</code> is a comment line which
is ignored. A line of at least five minus signs indicates the end of the
language description and the start of the tests. Otherwise, a line represents a
string matching rule, and consists of a state name, a list of pattern strings to
match, a target state name, and an optional one-character action code, all
separated by spaces. A state name starts with a letter and must be at least two
characters long. When the scanner is in the first state and one of the strings
in the list is matched, the scanner moves past the matched string in the input,
goes into the target state, and carries out the action. For example:</p>

<pre>start == != start +
</pre>

<p>With this rule, if the scanner is in the <code>start</code> state and either
of the equality symbols appears next, then the scanner moves past the symbol and
remains in the <code>start</code> state. The plus sign is an action which tags
the symbol as an operator. When a token is tagged, it consists of all the
characters since the end of the previous token. The tag is attached to the first
character of the token. All characters have to be accounted for, so a sequence
of spaces needs to be tagged as a gap token.</p>

<p>The pattern strings in a rule are plain text with no quotes. They may not
contain spaces, control characters, or non-ASCII characters. However, non-ASCII
Unicode characters are allowed in the text being scanned, and are treated the
same as letters (specifically, the same as the letter <code>'z'</code>). This
covers most common cases where such characters are allowed by programming
languages, in comments, strings or identifiers.</p>

<p>If a pattern string consists of two characters separated by two dots, it
represents a range of one-character strings, e.g. <code>0..9</code> stands for
<code>0 1 2 3 4 5 6 7 8 9</code>. For example:</p>

<pre>start a..z A..Z 0..9 id
</pre>

<p>This rule describes what happens when the scanner is in the
<code>start</code> state, and a letter or digit (or non-ASCII character) appears
next in the input. There is no explicit action character. The implicit default
action is 'accept' which accepts the matched text as part of the current token
without terminating it, moves past the matched text, and goes into the target
state.</p>

<p>The following escape sequences are recognized in language descriptions:</p>

<pre>\s     space
\n     newline
\b     backslash (not needed if a backslash is followed by white space)
\r     reject action (see later)
</pre>

<p>There may be multiple rules for the same state. If a string mentioned in any
one of the rules matches, that rule determines the action taken. For
example:</p>

<pre>start == != start +
start a..z A..Z 0..9 id
</pre>

<p>In the start state, if an equality symbol appears next in the input, it is
marked as an operator token. If a letter or digit appears, the scanner moves to
the <code>id</code> state. If two different strings match at one position in the
input, the longer string takes precedence. For example:</p>

<pre>start = start S
start == != start +
</pre>

<p>If there are two equal signs next in the input, the second rule applies, not
the first. If there is a single equal sign, the first rule applies. If the same
string is mentioned in multiple rules, the earlier rule takes precedence. Thus
later rules act as defaults. For example:</p>

<pre>start a..z A..Z 0..9 id
start \s..~ start ?
</pre>

<p>This says that if a letter or digit is matched, the scanner goes into the
<code>id</code> state. If any other character is matched, the scanner tags it as
invalid.</p>

<p>If a rule has no pattern strings at all, it matches the empty string, and so
defines a default action to be taken if nothing else matches, or if the input
position is at the end of the text. A tag only takes effect if the current token
is non-empty at that point. For example:</p>

<pre>id a..z A..Z 0..9 id
id start I
</pre>

<p>While letters and digits are matched, the scanner stays in the
<code>id</code> state. In any other case, the token is tagged as an identifier.
Each state should have a default rule of this kind, to ensure that scanning
always succeeds. The action characters are listed here:</p>

<pre>\s  accept (can be omitted)
\r  reject
_   gap, i.e. white space
+   operator
:   label indicator
'   open/close single-quoted literal
"   open/close double-quoted literal
`   open/close multi-line literal
(   open round bracket
)   close round bracket
[   open square bracket
]   close square bracket
{   open curly bracket
}   close curly bracket
%   open curly bracket used for initializer
&lt;   open multiline comment e.g. /*
>   close multiline comment e.g. */
#   open one-line comment e.g. //
$   newline, close one-line comment
?   invalid token
D   field
E   escape sequence
F   function
I   identifier
K   keyword
N   number
P   property
R   reserved word
S   sign e.g. = , ;
T   type
W   word
</pre>

<p>All actions other than accept and reject terminate the current token with a
tag. Upper case letters are used to tag tokens which only affect syntax
highlighting via theme files. Non-letter symbols are used to tag tokens which
have some syntactic significance potentially affecting bracketing, indenting,
continuation, wrapping etc. Bracket matching in the editor deals with such
things as delimiting comments and quoted literals, terminating one-line comments
at newlines, or marking a close curly bracket as belonging to an initializer
(which affects the handling of semicolons). That means, or example, that a
newline, or white space containing a newline, should be tagged with
<code>$</code> so that the bracket matcher can detect the end of a one-line
comment.</p>

<p>Since a token is not tagged until the end of the token is reached, decisions
about which tag to use can be delayed. For example, rules like these can be used
for a language where an identifier is allowed to start with a keyword:</p>

<pre>start a..z A..Z id
start if else for while key

key a..z A..Z 0..9 id
key start K

id a..z A..Z 0..9 id
id start I
</pre>

<p>Suppose the keyword <code>for</code> appears next in the input. Since
<code>for</code> is longer than the single letter <code>f</code>, the second
rule for the <code>start</code> state applies rather than the first. Then, in
the <code>key</code> state, if the keyword is followed by a letter or digit,
<code>form</code> for example, the scanner goes into the <code>id</code> state
and the token ends up being tagged as an identifier. Otherwise, <code>for</code>
is tagged as a keyword.</p>

<p>The reject action discards all the matched characters since the end of the
previous token, and untags the previous token. This provides some lookahead for
solving tougher problems. For example, suppose that identifiers are to be tagged
as <code>I</code> except that if one identifier is followed by another, the
first is to be tagged as <code>T</code> to highlight it differently as a type.
This could be achieved with rules like this:</p>

<pre>
start a..z A..Z id

id a..z A..Z 0..9 id
id idGap I

idGap \s idGap
idGap a..z A..Z idId \r
idGap typeId \r

idId start T

typeId start I
</pre>

<p>In the <code>id</code> rule, when there are no more letters or digits, the
token is tentatively tagged with <code>I</code>, and scanning passes to the
<code>idGap</code> rule. After any spaces are scanned, if a letter is seen in
the <code>idGap</code> state, a reject action moves the input position back to
the end of the tentative <code>I</code> token. The <code>idId</code> rule then
overwrites the <code>I</code> tag with a <code>T</code> tag. If anything else is
seen after the first identifier, a reject action moves back to the end of the
first identifier, leaves it tagged with <code>I</code> and passes control to the
<code>start</code> state.</p>

<p>A language description file has tests at the end, after a line of at least
five minus signs. Each test consists of two lines of text. Tests may be
separated by blank lines. The first line of a test consists of some program text
in the language being described. The second line shows the tags generated by the
scanner. The first character of a token is marked with its tag, and the
remaining characters of a token are marked with spaces.</p>

<p>The scanner is made reasonably incremental by finding the safe tags, i.e.
those which lead to unique states. For example, if any rule with the operator
tag <code>+</code> has <code>start</code> as its target state, then
<code>+</code> is a safe tag. After an edit to a document, the scanner finds the
nearest preceding token with a safe tag. The scanner can be started immediately
after that token in the safe tag's unique target state. Once scanning goes past
the edited text, it can stop after an unchanged token with a safe tag.</p>

</body>
</html>
