<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" xml:lang="en-GB">
<head>
<meta charset="UTF-8"/>
<style>
    body { font-size: 120%; }
    pre, .indent { margin-left: 40px; }
    img { display: block; margin: 0 auto; }
    mark {
      font-family: cursive;
      font-size: 95%;
      color: #080;
      background-color: white;
    }
</style>
<title>Snipe Customisation</title>
</head>
<body>

<h1>Languages</h1>

<p><mark>Snipe</mark> has a scanner, which is implemented as a string-matching
state machine, to divide the text of a file being edited into tokens, and to
give each token a type. A scanner for an editor has different goals from those
of a scanner in a compiler. On the one hand the scanner:</p>

<ul>
<li>may omit some details needed only for full compiling</li>
<li>may accept some tokens that a compiler would reject</li>
<li>may split or classify tokens differently</li>
<li>may be approximate</li>
</ul>

<p>One common reason for a scanner to be approximate is that the lexical rules
for a language depend on syntactic context. A multi-language editor doesn't
normally support full parsing of languages. On the other hand, the scanner:</p>

<ul>
<li>must partition the whole text into tokens</li>
<li>must be able to handle any text, whether valid or not</li>
<li>must produce token types suitable for editor features</li>
</ul>

<p>In addition, the scanner for Snipe is designed to be able to support other
editor features such as:</p>

<ul>
<li>dynamic loading of language definitions</li>
<li>incremental rescanning</li>
<li>cursor movement a 'word' at a time</li>
<li>bracket matching</li>
<li>line wrapping</li>
<li>indenting</li>
<li>semicolon insertion</li>
</ul>

<p>Scanners for multi-language editors are often expressed using regular
expressions. Scanners for Snipe are instead expressed as state machine tables.
These are simpler, easier to read and maintain, and only a little less
compact. Each language has a description in a text file, which is compiled into
a table in a binary file. These binary files can then be loaded dynamically as
necessary by Snipe.</p>

<p>A language scanner is described by a text file. For example, the C language
is described by the <code>c.txt</code> file in the directory
<code>snipe/languages</code>. The file is a description of a string-matching
state machine. A generic interpreter uses the state machine to perform
scanning.</p>

<h2>Rules</h2>

<p>A language description file is a plain text file. A line which is blank or
begins with a non-letter such as <code>#</code> or <code>/</code> is a comment
line which is ignored. Otherwise, a line represents a string-matching rule.</p>

<p>A simple rule has a base state name, a list of patterns to match, a target
state name, and a token type, all separated by spaces. A state name begins with
a lower case letter. A pattern is a sequence of non-space characters. A token
type starts with an upper case letter. For example:</p>

<pre>start == != start OP
</pre>

<p>When the scanner is in the base state of a rule and one of the patterns in
the list appears next in the input, the scanner moves past the matched
characters, and goes into the target state. The current token is terminated
after the matched characters and given that type. With the above rule, if the
scanner is in the <code>start</code> state and either of the equality operators
<code>==</code> or <code>!=</code> appears next in the input, then the scanner
moves past the operator, marks it as a token with type <code>OP</code>, and
remains in the <code>start</code> state.</p>

<p>A rule need not include a token type, in which case scanning of the current
token is continued. In the following example, when in the <code>start</code>
state, if a double quote character appears next in the input, the scanner moves
past it and goes into the <code>string</code> state to deal with the rest of the
token:</p>

<pre>start " string
</pre>

<p>A limited form of lookahead is provided. A lookahead rule has a plus sign
character at the end. For example:</p>

<pre>id ( start FUNCTION +
</pre>

<p>This rule says that in the <code>id</code> state, if an open bracket appears
next in the input text, the current token at this point is terminated and given
type <code>FUNCTION</code>, without including the bracket. The scanner then goes
into the <code>start</code> state to deal with the bracket.</p>

<p>A lookahead rule need not terminate the current token, i.e. it need not have
a token type. For example:</p>

<pre>start \ escape +
</pre>

<p>This says that in the <code>start</code> state, if a backslash occurs next in
the input, it is not immediately included in the current token. The scanner goes
into the target state <code>escape</code>, which is responsible for handling the
backslash.</p>

<p>A pattern in a rule must be non-empty, and must consist of printable basic
latin characters (often called ASCII, even though that refers to a long-obsolete
and non-international standard). It may not directly contain spaces, newlines,
or other control characters. A pattern normally matches a sequence of characters
in the text. For example, the keyword <code>while</code> can be matched with the
rule:</p>

<pre>start while start KEY
</pre>

<p>Although there is no provision for matching characters beyond basic latin,
any such character in the text is matched by the scanner, regardless of
language, anywhere a letter is allowed, which covers the most common conventions
for allowing such characters in identifiers, comments and string literals.</p>

<p>A pattern consisting of digits is a decimal character code. In particular,
<code>32</code> can be used for a space and <code>10</code> can be used for
a newline. For example:</p>

<pre>start 32 start GAP
start 10 start NEWLINE
</pre>

<p>A pattern can consist of two dots with a printable character on either side.
It represents a range of one-character patterns, e.g. <code>0..9</code> stands
for <code>0 1 2 3 4 5 6 7 8 9</code>:</p>

<pre>start 0..9 number
</pre>

<p>This rule says that if the scanner is in the <code>start</code> state, and a
digit appears next in the input, the scanner matches the digit and goes into the
<code>number</code> state.</p>

<p>A pattern consisting just of two dots is used to represent any remaining
basic latin character which has not already been dealt with. For example:</p>

<pre>id .. start ID +
</pre>

<p>This is a default rule which says that, while scanning an id, if any
unexpected character is encountered, other than a letter or digit, the id should
be terminated before that character.</p>

<p>If a lookahead default rule has no token type, it is effectively an
unconditional jump to another state. For example:</p>

<pre>directive .. start +
</pre>

<p>The <code>directive</code> state might be used to recognise a special
sequence of tokens. This rule says that if anything further appears in the
input, the scanner reverts to the <code>start</code> state to handle it.</p>

<h2>States</h2>

<p>A state is defined by the rules which have that state as their base state.
The rules defining a state need not necessarily be contiguous, but the order
that they appear in matters.</p>

<p>If the input matches a pattern mentioned in any one of the rules for a state,
that rule is applied. In the following example, in the <code>start</code> state,
if an equality operator appears next in the input, it is marked with type
<code>OP</code>, whereas if a letter appears, the scanner goes into the
<code>id</code> state:</p>

<pre>start == != start OP
start a..z A..Z id
</pre>

<p>If two different patterns match at one position in the input, the longer
pattern takes precedence. In this example, if there are two equal signs next in
the input, the second rule applies, not the first. If there is only a single
equal sign, the first rule applies:</p>

<pre>start = start SIGN
start == != start OP
</pre>

<p>If the same pattern is matched by multiple rules, the earlier rule takes
precedence. Thus later rules act as defaults. Even though the rules for a state
need not be contiguous, the order in which they appear in the description file
may matter. For example:</p>

<pre>string " start QUOTED
string .. string
</pre>

<p>These rules say that, while recognizing a string literal in double quotes, a
double quote character terminates the token, even though the double quote
character is also matched by the second rule, which acts as a default, matching
and accepting any character other than a double quote.</p>

<p>Since a token is not given a type until the end of the token is reached,
decisions about which type to use can be delayed. For example, rules like these
can be used for a language where an identifier is allowed to start with a
keyword:</p>

<pre>start a..z A..Z id
start if else for while key

key a..z A..Z 0..9 id
key .. start KEY

id a..z A..Z 0..9 id
id .. start ID
</pre>

<p>Suppose the keyword <code>for</code> appears next in the input. Since
<code>for</code> is longer than the single letter <code>f</code>, the second
rule for the <code>start</code> state applies rather than the first and the
scanner goes to the <code>key</code> state which gives the token the type
<code>KEY</code>.</p>

<p>Suppose instead that the identifier <code>form</code> appears next in the
input. The prefix <code>for</code> is matched and the scanner goes into the
<code>key</code> state. Then the <code>m</code> is matched and the scanner goes
into the <code>id</code> state and the token ends up being given type
<code>ID</code>.</p>

<h2>Correctness checks</h2>

<p>When a language description is processed, various checks are made for correct
behaviour. The checks ensure that the scanner never fails, creates non-empty
tokens, partitions the input by including every character in a token, handles
all possible inputs, and terminates without getting stuck in a loop</p>

<p>Every target state mentioned in the rules must be a defined state, i.e. one
which appears as the base state of at least one rule.</p>

<p>Every state must handle all possible inputs. A simple check is made that each
state has a default rule using the <code>..</code> notation. There is also a
check that the default rule is last, because rules after a default rule would be
unreachable.</p>

<p>Every state is classified either as a <dfn>starting</dfn> state, which the
scanner is in when between tokens, or a <dfn>continuing</dfn> state, which the
scanner is in when within a token. A check is made to ensure that each state is
consistently treated as one or the other. This helps to ensure that the scanner
partitions the whole of the input text into non-empty tokens.</p>

<p>The base state of the first rule in the description is the initial state of
the scanner, so it is a starting state. Any state which appears as the target in
a rule with a token type must also be a starting state. For example:</p>

<pre>start # hash SIGN
</pre>

<p>This rule might be used in the C language, to recognise preprocessor
directives such as <code>#include</code>. After the <code>#</code> token,
<code>include</code> is a keyword rather than an identifier. The
<code>hash</code> state is a starting state for recognising such keywords only
in this limited context. Another example is:</p>

<pre>html &lt;% java SIGN
java %> html SIGN
</pre>

<p>These rules might be used in a language such as <code>JSP</code> where html
text can contain Java program fragments between <code>&lt;%</code> and
<code>%></code> brackets. The <code>html</code> and <code>java</code> states are
starting states which recognize each of the two sublanguages.</p>

<p>If a state is the target of a non-lookahead rule which has no token type,
then it is a continuing state. For example, the <code>id</code> state must
be a continuing state if the scanner includes this rule:</p>

<pre>start a..z A..Z id
</pre>

<p>Also, if a state is the base of a lookahead rule with a token type, it must
be a continuing state, otherwise it would be creating an empty token. For
example, the <code>id</code> state must be a continuing state if it contains the
rule:</p>

<pre>id .. start ID +
</pre>

<p>Once each state has been classified as a starting or continuing state, a
further check is made that a lookahead rule with no token type has base and
target states which are both starting states or both continuing states. For
example, <code>directive</code> and <code>start</code> are deduced to have the
same classification if the scanner includes this rule, which is effectively a
jump:</p>

<pre>directive .. start +
</pre>

<p>An example where an error arises because states are not handled consistently
might be:</p>

<pre>dot 0..9 number
dot a..z A..Z prop SIGN +
dot .. start +

prop a..z A..Z 0..9 prop
prop .. start PROPERTY +
</pre>

<p>The idea behind these rules is that if a dot is followed by an identifier,
the identifier should be highlighted differently, as a <code>PROPERTY</code>.
However, the <code>prop</code> state is classified as a starting state, because
it follows the completion of a <code>SIGN</code> token in the second
<code>dot</code> rule. On the other hand, it has to be a continuing state,
both because it is the target of its own first rule, and because it completes a
<code>PROPERTY</code> token in its second rule. This can be corrected by
writing:</p>

<pre>dot 0..9 number
dot .. prop0 SIGN +

prop0 a..z A..Z prop1
prop0 .. start +

prop1 a..z A..Z 0..9 prop1
prop1 .. start PROPERTY +
</pre>

<p>Now, <code>prop0</code> is a starting state which matches only the first
letter, and <code>prop1</code> is a continuing state which recognizes the rest
of the token.</p>

<p>A lookahead rule makes no progress in the input, so there is a check that
there is no cycle of lookahead rules which could result in an infinite loop when
scanning. For example:</p>

<pre>even a..z odd +
odd a..z even +
</pre>

<p>These rules would cause the scanner to continue indefinitely if a letter
appeared next in the input.</p>

<h2>Conventions</h2>

<p>==========</p>

<p>Source text to be scanned is normalized, so that it does not contain any
control characters such as tabs or carriage returns. The only basic latin
characters that cannot be matched explicitly are spaces and newlines, and these
can be handled by empty and default rules. For example:</p>

<pre>start !..~ start ERROR
start start NEWLINE
start .. start GAP
</pre>

<p>The first rule handles any printable characters that have not already been
handled, the second handles a newline, and the third handles a space as the only
remaining character.</p>

<p>TODO: spaces are adapted automatically. Spaces within a token divide it into
similar tokens, with each space marked as <code>_</code> to indicate a gap.
CHECK: a space appears on its own at least once (start state?), and is always
marked as the same type (GAP).</p>

<p>TODO: Newlines are adapted automatically. A newline within a token is treated
like a space. A newline on its own (or at the end of a token) is marked with
<code>.</code> as an active newline, causing automating indenting on the next
line. CHECK: a newline on its own is always marked with the same type
(NEWLINE).</p>

<p>TODO: Brackets are adapted automatically. A bracket has a type with a digit
suffix. CHECK: each digit is always attached to a type starting with the same
letter.</p>

<p>TODO: types are determined only by their first letter, which is not built
into Snipe. But those first letters must match the style settings. However, the
letter for white space (G) active newline (N) and bracket type (B, or 0..9
mapping) are noted.</p>

<p>TODO: warn if token ends in newline.</p>

<p>The Snipe scanner does not just give each token a type for syntax
highlighting purposes. It also supports further editor features, and some
conventions are needed for this to work. Not all these conventions can be
tested, but if a violation is detected, a warning is issued rather than an
error.</p>

<p>Source files are normalised by Snipe so, in the scanner, spaces and newlines
are the only characters that need to be represented by their codes. To support
commands that move the cursor a 'word' at a time, and to allow incremental
scanning, each space and newline is treated as a one-character token. Thus a
long comment or quoted literal needs to be divided into mini-tokens. For
example, a multi-line comment might be dealt with like this:</p>

<pre>start /* comment
comment */ start COMMENTED
comment !..~ comment
comment commentGap COMMENTED +
comment .. commentGap COMMENTED +
commentGap comment GAP
commentGap .. comment GAP
</pre>

<p>In these rules, a space or a newline is marked as a separate <code>GAP</code>
token, so that the editor can recognise it and skip past it when moving a 'word'
at a time. Scanning is incremental because the scanner state can be stored at
each space or newline and after an edit, scanning can be re-started at the
nearest preceding space or newline. Note that it is not possible to lookahead
past a space or newline, because it can't be included in a longer pattern, so
the scanner state at that point does not depend on any of the following
characters.</p>

<p>To handle automatic indenting, a newline should be given the token type
<code>NEWLINE</code> if it is 'active', i.e. not included in a comment or quote,
so that the immediately following line is one that should be indented:</p>

<pre>start start NEWLINE
</pre>

<p>Newlines which are inactive, because they are in comments or quoted literals,
should have type <code>GAP</code>.</p>

<p>To handle automatic bracket matching, a bracket should be given one of the
types <code>OPEN0, CLOSE0, OPEN1, CLOSE1, OPEN2, CLOSE2, OPEN3, CLOSE3</code>
which represent increasing priority. For a curly bracket language, brackets
might be handled like this:</p>

<pre>start ( start OPEN0
start ) start CLOSE0
start [ start OPEN1
start ] start CLOSE1
start { start OPEN2
start } start CLOSE2
</pre>

<p>In a language where keywords <code>begin</code> and <code>end</code> are used
for blocks instead of curly brackets, the last two rules might be replaced
by:</p>

<pre>start begin start OPEN2
start end start CLOSE2
</pre>

<p>If a bracket is not active because it is inside a comment or string literal,
it should have, or be part of a token with, type <code>COMMENTED</code> or
<code>QUOTED</code>.</p>

<p>To ease the writing of tests, each token type can be abbreviated to a single
character. The full set of token types is currently:</p>

<p class="indent"><code>OPEN0 CLOSE0 OPEN1 CLOSE1 OPEN2 CLOSE2 OPEN3 CLOSE3
COMMENTED ERROR FUNCTION GAP ID KEY NEWLINE OP PROPERTY QUOTED RESERVED SIGN
TYPE VALUE</code></p>

<p>These can all be abbreviated to their first characters, except for the
brackets, which are abbreviated to <code>( ) [ ] { } &lt; ></code>. In addition,
<code>GAP</code> or <code>NEWLINE</code> can be written as a space or a dot
rather than a <code>G</code> or an <code>N</code>.</p>

<p>A typical test might appear something like this:</p>

<pre>struct *point = { x, (y+1) }; int ns = [(n+2),3];
K+++++ SI++++ S { IS (IOV) }S K++ I+ S [(IOV)SV]S.
K+++++_SI++++_S_4_IS_0IOV1_5S_K++_I+_S_20IOV1SV3S.
</pre>

<p>The first line represents some input text, and the line below represents the
result of scanning. The first character of each token is marked below by the
one-character abbreviation of its token type, and the remaining characters of a
token are marked by dashes.</p>

<p></p>

<h2>Compiling...</h2>







<p>A language description in <code>tokens.txt</code> can be compiled into a
table using <code>compile.c</code> in <code>snipe/languages</code> and then
executed for testing using <code>interpret.c</code>. The interpreter carries out
tests in a file <code>tests.txt</code>. Each test consists of optional comment
lines starting with <code>#</code>, followed by a line of text, followed by a
line of tags generated by the scanner. For example:</p>

<p>Thus the type of a token may be affected by the next token, but no more than
that. To scan incrementally in the editor, when a token is altered, the editor
needs to go back at least as far as the beginning of the previous token before
the changed one, and find what state the scanner was in at that point, to start
re-scanning.</p>

<h3>Scanner operation</h3>

<p>The current state of the scanner can be recorded now and then, e.g. at the
start of each line of the text. Then, when some text changes while editing,
re-scanning of the changed text need begin no earlier than at the start of the
affected line. Re-scanning would then continue until synchronisation, i.e. until
the current state of the scanner at the start of a line matches the previous
state recorded at that point. It is desirable that this synchronisation should
happen after only a line or two, to avoid visual instability for the user as
well as inefficiency in the editor. Scanning is then effectively
incremental.</p>

<p>The first state to be defined in a language description is the default one
for the scanner to start in. It is normal for most tokens to be scanned starting
from that first state, with other states being defined to handle progression
through each token. In that case, re-scanning is sure to be brief. However,
alternative start states for tokens can be used to handle unusual
situations.</p>


<h3>Bracket Matching</h3>

<p>TODO: explain forward algorithm. Assume only brackets. As well as text, there
are two stacks: unmatched and matched. (Picture with ... for cursor position.)
The unmatched stack contains indexes of currently unmatched open brackets (as
standard). The matched stack contains matched (open,close) pairs of indexes. The
indexes of the close brackets are in text order. Changes as you add or remove a
bracket at the cursor are very small and incremental and efficient.  Two
mismatched brackets are treated as matched, except that they are both
highlighted as invalid. Incremental.</p>

<p>TODO: explain backward algorithm. Entirely symmetrical. Note that the indexes
are measured leftwards from the end of the text, so that they remain stable as
insertions and deletions happen at the cursor.</p>

<p>TODO: explain inwards algorithm. The two stacks are compared inwards.
Mismatching pairs are highlighted red. Remaining surplus brackets are
highlighted red. Give examples showing 'just typed' effects.</p>

<p>After scanning into tokens, a matching algorithm is used to pair up brackets
and delimiters. Some aims of the Snipe approach are to:</p>

<ul>
<li>highlight unmatched brackets and delimiters</li>
<li>have small edits produce small changes</li>
<li>make the algorithm incremental</li>
</ul>

<p>If brackets don't match, there is an ambiguity about which brackets to mark
as unmatched. For example, the sequence <code>(()</code> can be treated in
either of these two ways:</p>

<pre class="match">(<b>(</b>)
<b>(</b>()
</pre>

<p>In the first case, the outer brackets are matched and the inner one is
highlighted as unmatched. In the second case, the rightmost brackets are
matched, and the leftmost one is marked as unmatched.</p>

<p>If the user has just typed one of the two open brackets, that is the one that
is most intuitively highlighted as unmatched. That suggests a matching algorithm
based on the user's history. However, that would make it awkward to save and
reopen files, and it could easily become counter-intuitive.</p>

<p>Instead, Snipe uses a matching strategy which is based purely on the text
together with the user's current cursor position. Brackets are matched forwards
from the start of the text up to the cursor, and backwards from the end of the
text to the cursor. Surplus brackets on either side of the cursor are then
matched up from outermost to innermost. Using three dots to mark the cursor
position, the three brackets above are handled like this:</p>

<style>
pre.match { color: black; }
pre.match i { color:black; font-style: normal; background-color: lightgrey; }
pre.match b { color: red; }
pre.match u { color: green; text-decoration: none; }
</style>

<pre class="match">(<b>(</b><u>...</u>)
<b>(</b><u>...</u>()
</pre>

<p>In the first case, there are two surplus brackets before the cursor and one
after, and the outermost two are matched. In the second case, there are no
surplus brackets after the cursor, so the leftmost bracket is mismatched.</p>

<p>The situation is complicated by multiline comments. Let's suppose that they
are delimited by <code>/*</code> and <code>*/</code> and that these don't nest,
as in many C-like languages. These comments cause two main problems. One is that
commenting out goes wrong when there is an inner comment. The other is that
inserting or deleting a comment delimiter can cause a large amount of text to be
re-scanned, which is sometimes inefficient enough to cause a noticeable and
irritating delay. In any case, it causes a large amount of changed highlighting
on screen, which can be annoying.</p>

<p>The approach in Snipe, to avoid these problems, is to treat <code>/*</code>
as illegal inside comments (as <code>*/</code> already is) and, as with
brackets, use both forward and backward matching. In addition, the effect of an
unmatched comment delimiter only extends as far as the cursor. For example:</p>

<pre class="match"><i>/*...<b>/*</b>...*/</i>...<b>*/</b>
<b>/*</b>...<i>/*...<b>*/</b>...*/</i>
</pre>

<p>In the first case, the cursor is beyond the text fragment. The first and
third delimiters are matched, and the text between is highlighted as a comment.
The second and fourth delimiters are highlighted as unmatched. This is as
expected, except for the highlighting of the second delimiter.</p>

<p>In the second case, the cursor is before the text fragment. Working
backwards, the fourth and second delimiters are matched, with the text between
them highlighted as a comment, leaving the third and first delimiters unmatched.
Although this highlighting doesn't agree with the language conventions, it is a
reasonable approach once internal delimiters are regarded as invalid, and the
need for correction is clearly indicated.</p>

<p>To see the full effect on highlighting, here is a sequence of user actions in
which an attempt is made to comment out some text which already contains a
comment:</p>

<pre class="match"><u>:</u>...<i>/*...*/</i>...
<i><b>/*</b></i><u>:</u>...<i>/*...*/</i>...
<i><b>/*</b>...</i><u>:</u><i>/*...*/</i>...
<i>/*...<b>/*</b></i><u>:</u><i>...*/</i>...
<i>/*...<b>/*</b>...</i><u>:</u><i>*/</i>...
<i>/*...<b>/*</b>...</i><i>*/</i><u>:</u>...
<i>/*...<b>/*</b>...</i><i>*/</i>...<u>:</u>
<i>/*...<b>/*</b>...</i><i>*/</i>...<b>*/</b><u>:</u>
</pre>

<p>At the first step, an opening delimiter is typed. At the second, the cursor
is moved past some text, which becomes highlighted as comment. Then the cursor
is moved past the second opening delimiter, which becomes highlighted as
unmatched. The first and third delimiters match, as surplus delimiters either
side of the cursor. Then the cursor is moved past some text which is unchanged,
and a final delimiter is typed, which is immediately highlighted as
unmatched.</p>

<p>During the sequence, the only changes on the screen are immediately adjacent
to the cursor, with possibly one change of highlighting to a delimiter further
away. And the changes are, arguably, very intuitive.</p>

</body>
</html>
