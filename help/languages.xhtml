<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" xml:lang="en-GB">
<head>
<meta charset="UTF-8"/>
<style>
    body { font-size: 120%; }
    pre, .indent { margin-left: 40px; }
    img { display: block; margin: 0 auto; }
    mark {
      font-family: cursive;
      font-size: 95%;
      color: #080;
      background-color: white;
    }
</style>
<title>Snipe Customisation</title>
</head>
<body>

<h1>Languages</h1>

<!-- TODO C++, Java, Python, Haskell, HTML -->

<p><mark>Snipe</mark> has a scanner, which is implemented as a string-matching
state machine. It divides a source text into
tokens, and gives each token a type. The result may be approximate, compared to
a scanner in a compiler, especially if a language has token rules which depend
on the current parsing context. On the other hand, the Snipe scanner:</p>

<ul>
<li>partitions the whole text into tokens, whether valid or not</li>
<li>supports dynamic loading of language definitions</li>
<li>supports incremental rescanning</li>
<li>includes bracket matching, using a stack</li>
<li>aids indenting, semicolon insertion, and comment reformatting</li>
</ul>

<p>Languages for programming editors are often expressed using regular
expressions. Languages for Snipe are instead expressed as string-matching state
machine tables. These are easier to read and maintain, and only a little less
compact.</p>

<p>For example, the C language is described by the <code>c.txt</code> file in
the directory <code>snipe/languages</code>. The commands <code>make
compile</code> and <code>./compile c.txt</code> can be used to compile the
file. The compiler analyses the language definition to ensure that the scanner
can handle any source text, that it can't get stuck in an infinite loop, and
that it can't produce empty tokens. It then carries out tests which are
included in the <code>c.txt</code> file and, if they pass, produces a compact
table in file <code>c.bin</code> for use by Snipe's scanner.</p>

<h2>Rules</h2>

<p>A language description contains simple text (<u title="aka ASCII (obsolete
and non-international)">basic Latin</u> characters <code>' '</code> to
<code>'~'</code> plus <code>'\n'</code>). The rules in the file specify how
simple source text is divided into tokens. The scanner which uses the
description treats every Unicode character beyond basic Latin in the same
way as letters. That is sufficient to handle the common uses of Unicode in
identifiers, string literals and comments.</p>

<p>In a language description file, a line which is blank or begins with a
non-letter such as <code>#</code> or <code>/</code> is a comment line which is
ignored, or a line used for testing. Otherwise, a line represents a
string-matching rule.</p>

<p>A rule has a base state name, a list of patterns to match, and a target
state name, optionally followed by a tag, all separated by spaces. A state
name is a lower case word, possibly including digits. A pattern is any
sequence of non-space characters. A tag is an upper case word, possibly
including digits. When the scanner is in the base state of a rule and one of
the patterns appears next in the input, the scanner moves past the matched
characters to include them in the token currently being scanned, and goes into
the target state. For example:</p>

<pre>start " string
</pre>

<p>With this rule, if the scanner is in the <code>start</code> state and a
double quote character appears next in the input, the scanner moves past the
character and goes into the <code>string</code> state.</p>

<p>If a rule has a tag, the current token is ended, with the tag as its type.
The tag should be one of those expected by Snipe. For example:</p>

<pre>start == != start OP
</pre>

<p>With this rule, in the <code>start</code> state, if either of the equality
operators <code>==</code> or <code>!=</code> appears next in the input, then
the scanner moves past the operator, marks it as a token with type
<code>OP</code>, and goes to the <code>start</code> state.</p>

<p>A pattern can consist of two dots with a character on either side. It
represents a range of one-character patterns, e.g. <code>0..9</code> stands
for <code>0 1 2 3 4 5 6 7 8 9</code>. For example:</p>

<pre>start 0..9 number
</pre>

<p>This rule says that if the scanner is in the <code>start</code> state, and
a digit appears next in the input, the scanner matches the digit and goes into
the <code>number</code> state. The pattern <code>!..~</code> can be used to
match any character other than space or newline.</p>

<p>A limited form of lookahead is provided. A pattern which starts with a
single backslash <code>\</code> is a lookahead pattern. It indicates a string
to be matched without being included in the current token. For example:</p>

<pre>id \( start FUNCTION
</pre>

<p>In the <code>id</code> state, which presumably recognizes identifier tokens,
if the next character in the source text is an open bracket, the current token
is marked as a <code>FUNCTION</code> instead of the usual identifier type. That
allows a function name to be highlighted differently when immediately followed
by an open bracket, but the same approach can't be used to recognise <code>f
(</code> because by the time the <code>(</code> is reached, it is too late to
change the type of the token <code>f</code>. A lookahead pattern can also be a
range:</p>

<pre>dot \0..9 float
</pre>

<p>In the <code>dot</code> state, presumably just after recognizing a dot
character, if a digit appears next in the source text, the scanner goes to the
<code>float</code> state without moving past the digit.</p>

<p>A lookahead pattern <code>\s</code> matches a space and <code>\n</code>
matches a newline. When used in a rule with a tag, the effect is the same as for any other lookahead. For example:</p>

<pre>id \s \n start ID
</pre>

<p>Here, while scanning an identifier, if a space is encountered next in the
input, the identifier is given type <code>ID</code> and the scanner goes to the
<code>start</code> state to deal with the space. The rule may have no tag. For
example:</p>

<pre>start \s \n start
</pre>

<p>In this case, there is a side effect, which is that the space or newline is
tagged as a separator and skipped before entering the target state. Neither a
space nor a newline can be included in tokens. Other single-letter lookahead
patterns such as <code>\x</code> are treated as errors. A literal single letter
<code>x</code> can be recognized as a lookahead using a range
<code>\x..x</code>.</p>

<p>A pattern beginning with two backslashes such as <code>\\u</code> is a
non-lookahead pattern matching a string such as <code>\u</code> starting with a
single backslash. A pattern beginning with three backslashes such as
<code>\\\u</code> is a lookahead for a string such as <code>\u</code> starting
with a single backslash. A backslash anywhere else in a pattern stands for
itself. A pattern <code>\</code> consisting of just a backslash is treated as
an abbreviation for <code>\!..~ \s \n</code> matching any character as a
lookahead.</p>

<h2>States</h2>

<p>A state is defined by the rules which have that state as their base state.
The base state of the first rule in a language description is the starting
state for the scanner when scanning of a source text begins.</p>

<p>The rules defining a state can be in any order and need not necessarily be
contiguous. If the input matches a pattern mentioned in any one of the rules
for a state, that rule is applied. For example:</p>

<pre>start == != start OP
start a..z A..Z id
</pre>

<p>In the <code>start</code> state, if an equality operator appears next in the
input, it is marked with type <code>OP</code> and the scanner remains in the
<code>start</code> state, whereas if a letter appears, the scanner goes into
the <code>id</code> state. If two different patterns, whether normal or
lookahead, match at one position in the input, the longer pattern takes
precedence:</p>

<pre>start = start SIGN
start == != start OP
</pre>

<p>In this example, if there are two equal signs next in the input, the second
rule applies, not the first. If there is only a single equal sign, the first
rule applies. If a single character is matched directly by one pattern and as
part of a range in another pattern, the direct pattern takes precedence:</p>

<pre>string !..~ string
string " start STRING
</pre>

<p>Here, if a double quote <code>"</code> is next in the input, the second rule
is applied, even though <code>"</code> is included in the range in the first
rule. If a single character is matched by two ranges, and one is a subrange of
the other, the subrange takes precedence. For example:</p>

<pre>id a..z A..Z 0..9 id
id \ start ID
</pre>

<p>If a letter or digit appears next, the first rule applies, even though
letters and digits are included in the implicit range in the second rule. If
any other character appears, the second rule applies.</p>

<p>Any ambiguity not covered above between two patterns in the rules for a state
is an error.</p>

<p>When a language description is processed, various checks are made to ensure
that the scanner never fails, creates non-empty tokens, partitions the whole
input into tokens and separators, handles all possible inputs, and terminates
without getting stuck in a loop.</p>

<p>There is a check that every state has at least one rule, does not contain
duplicate patterns, and handles all the single characters
<code>!..~ \s \n</code> in some way. Where a lookahead pattern in a rule with
no tag causes a jump between states without consuming input, there is a check
that no infinite loop of jumps can occur.</p>

<p>To prevent empty tokens, there is a check that each state is a starter or a
continuer, i.e. always occurs at the start of tokens, or always occurs after
the start. It is easy to tell the difference, because a starter state must not
have a tag when <code>\s</code> or <code>\n</code> is matched, whereas a
continuer state must have a tag when they are matched.</p>

<p>If a rule has a tag, the target state must be a starter. If a rule has a
non-lookahead pattern and no tag, the target state must be a continuer. If a
rule has a lookahead pattern and no tag, the target state must be a starter or
a continuer, according to whether the base tag is a starter or continuer.
Finally, if a starter state has a rule containing a lookahead, the rule must
not have a tag, because that would create an empty token.</p>

<h2>Tags</h2>

<p>These are the available tags:</p>

<pre>KEYWORD, TYPE, MARK,               - kinds of keyword
IDENTIFIER, FUNCTION, PROPERTY,    - kinds of identifier
VALUE, QUOTE, DOCUMENT,            - literals
BEGIN0...BEGIN7, END0...END7,      - block brackets
LEFT0...LEFT7, RIGHT0...RIGHT7,    - inline brackets
BEIN, END, LEFT, RIGHT,            - brackets not used in bracket matching
NOTE, COMMENT,                     - one-line and multi-line comments
OP, UNARY, SIGN, JOIN,             - operators and punctuation
WRONG                              - malformed token
</pre>

<p>These can be shortened, e.g. <code>KEY</code>, <code>ID</code>, or even to
one letter, e.g. <code>V</code>, <code>B0</code>. The scanning conventions and
the tags are designed to help with bracket matching, reformatting, syntax
highlighting, indenting, semicolon insertion, and incremental rescanning as
follows.</p>

<p><b>Bracket matching:</b> A stack of open bracket tags is maintained by the
scanner. For example:</p>

<pre>start { start BEGIN0
start } start END0
</pre>

<p>When an open curly bracket is matched by the first rule, <code>BEGIN0</code>
is pushed on the stack. When a close curly bracket is matched by the second
rule, the stack is popped. If the two tags do not match, the brackets can be
marked as mismatched. This bracket matching can be used to control the actions
of the state machine. For example:</p>

<pre>start } state1 END0
start } state2 RIGHT1
</pre>

<p>In this case, suppose an open curly bracket can be tagged either as
<code>BEGIN0</code> or as <code>LEFT1</code>, in two different states in the
language definition. When a close curly bracket is matched in the
<code>start</code> state, the relevant one of the two rules shown matches,
causing a jump to one of two different states. If neither rule matches, the
brackets are marked as mismatched and the scanner stays in the
<code>start</code> state.</p>

<p><b>Reformatting:</b> A multi-line comment or a sequence of one-line comments
is reformatted by changing the line breaks so that the maximum number of tokens
fit on each line. The scanning conventions help with this by ensuring that
spaces and newlines are always treated as separators, with comments being
divided into word-like tokens. Lines in multi-line comments which begin with a
space, and one-line comments with two or more spaces after the initial symbol,
are not reformatted. The small tokens also help with word-based cursor
movement.</p>

<p><b>Syntax highlighting:</b> Each token type can be displayed differently,
according to a style definition.</p>

<p><b>Indenting:</b> Snipe has a very simple and uniform rule for fully
automatic indenting. The indent of a line is determined by the number of
unmatched open brackets in the file, up to the end of the line. Lines belonging
to multi-line constructs, i.e. lines starting with a <code>COMMENT</code> or
<code>DOCUMENT</code> token, are not automatically indented, whereas lines
starting with a <code>NOTE</code> or <code>QUOTE</code> are.</p>

<p><b>Semicolon insertion:</b> Snipe inserts semicolons at the ends of lines
where appropriate, using a simple and uniform rule. A line should have a final
semicolon added unless it ends with a prefix token, or the following line
begins with a postfix token. A token is regarded as prefix if it expects an
immediately following token other than semicolon, as postfix if it expects an
immediately preceding token other than semicolon, as infix if it is both, and
as nonfix if it is neither.</p>

<p>Most token types are nonfix. The types <code>OP</code>, <code>SIGN</code> and
<code>JOIN</code> (line joiner such as backslash) are infix. Signs
(e.g. <code>...</code>) which are nonfix should be given a type such as
<code>MARK</code>. A <code>UNARY</code> operator (e.g. <code>++</code>) is
regarded as nonfix, on the assumption that a newline never separates it from
its operand. An operator such as minus which can be either prefix or infix
should be given type <code>OP</code> so that it is treated as infix, on the
assumption that a prefix version never appears at the start of a line.</p>

<p>Brackets of type <code>LEFT</code> or <code>RIGHT</code> are treated as
prefix and postfix respectively. A <code>BEGIN</code> bracket is treated as
infix rather than prefix, on the assumption that it is the start of a block
which is attached to the end of a statement so shouldn't be preceded by a
semicolon. An <code>END</code> bracket is treated as prefix rather than
postfix, on the assumption that a semicolon is appropriate before it but not
after it.</p>

<p>Languages in the C family often use curly brackets <code>{}</code> both as
block brackets and as structure brackets. In the latter case, a semicolon is
required after the close bracket. To cope with this, the language definition
should, at least approximately, tag the open bracket of a structure as
<code>LEFT</code> rather than <code>BEGIN</code>, according to context. The
bracket matcher can then adjust the tag of the end bracket to
<code>RIGHT</code> to match, so that a semicolon is expected after it.</p>

<p><b>Incremental rescanning:</b> A line of source text can be rescanned in
isolation, using only a recorded start state for the line, and the relevant
stack of tags. The stack can be reconstructed where necessary.</p>

<p>When a newline is matched with a <code>\n</code> lookahead pattern, the
target state can be recorded as the starting state for the line following the
newline. The scanner can then rescan the line in isolation by starting in that
state. A scanning state can, in general, depend on characters beyond the
current scanning position, because of lookahead patterns. However, language
rules cannot look ahead past a newline, so the start state for a line depends
only on the previous lines.</p>

<p>If the target state after rescanning a changed line is not the same as the
recorded start state of the next line, the next line may have to be rescanned
as well, and there are occasional cases where a lot of rescanning might be
required. The fact that lines can be rescanned in isolation makes it easy to
interleave rescanning with user actions, to avoid long pauses.</p>

<h2>Examples</h2>

<p>In many programming languages, an identifier is allowed to start with a
keyword. In that case, identifiers can be handled by rules like these:</p>

<pre>start  if else for while  key
start  a..z A..Z          id

key    a..z A..Z 0..9     id
key    \                  start KEY

id     a..z A..Z 0..9     id
id     \                  start ID
</pre>

<p>Suppose the keyword <code>for</code> appears next in the input. The scanner
goes to the <code>key</code> state which gives the token the type
<code>KEY</code>. Suppose instead that the identifier <code>form</code> appears
next in the input. The prefix <code>for</code> is matched and the scanner goes
into the <code>key</code> state. Then the <code>m</code> is matched, the
scanner goes into the <code>id</code> state, and the token ends up being given
the type <code>ID</code>.</p>

<p>Where language constructs contain spaces or newlines and so need to be
divided into mini-tokens, two states are often needed, one for the start of the
mini-tokens, and one for continuing the mini-tokens. For example, one-line
comments, say starting with <code>//</code> and continuing to the end of the
line, can be handled with rules of the form:</p>

<pre>start    //     note NOTE

note     !..~   note1
note     \s     note
note     \n     start

note1    !..~   note1
note1    \s     note NOTE
note1    \n     start NOTE
</pre>

<p>A comment line then consists of a sequence of tokens of type
<code>NOTE</code>, separated by spaces.</p>

<p>Multi-line comments, say starting with <code>/*</code> and ending with
<code>*/</code> and not nesting, can be handled by:</p>

<pre>start      /*         comment COMMENT

comment    !..~       comment1
comment    \s \n      comment
comment    */         start COMMENT

comment1   !..~       comment1
comment1   \s \n      comment COMMENT
comment1   */         start COMMENT
</pre>

<p>Languages in the C family often use curly brackets both for blocks and for
structures. The semicolon insertion rules are different in the two cases, so it
is desirable to tag them, say, as <code>BEGIN0</code>, <code>END0</code> in the
first case, and as <code>LEFT0</code>, <code>RIGHT0</code> in the second case.
One of the situations in which curly brackets are used for structures is;</p>

<pre>obj = (...) { ... }
</pre>

<p>The round brackets can, in principle, contain an arbitrarily complex type
expression, with brackets of its own. By giving these round brackets different
tags from the usual ones, the scanner can match them up and so detect the
following structure brackets. Suppose ordinary round brackets are tagged
<code>LEFT1</code>, <code>RIGHT1</code> and the ones surrounding a type
expression are tagged <code>LEFT2</code>, <code>RIGHT2</code>. Then the above
situation can be handled with rules of the form:</p>

<pre>start { start BEGIN0
start ( start LEFT1
start = eq OP

start } start END0
start } start RIGHT0
start ) start RIGHT1
start ) eqtype RIGHT2

eq ( start LEFT2

eqtype { LEFT0
</pre>

<p>After matching an equal sign, the <code>eq</code> state causes a
<code>LEFT2</code> tag to be pushed on the stack. It then returns to the
<code>start</code> state to process the type expression. When the
<code>LEFT2</code> tag comes back to the top of the stack and the open round
bracket is matched, the scanner jumps to the <code>eqtype</code> state to give
the following curly bracket the alternative tag.</p>

<p>Some languages support template strings, with embedded substitution
expressions. for example:</p>

<pre>`a = ${a} and b = ${b}`
</pre>

<p>An expression between <code>${</code> and <code>}</code> can be arbitrarily
complicated, including its own curly brackets and template delimiters, so these
brackets need to be matched in order to detect the return to the parent
template. By treating <code>${</code> and <code>}</code> as brackets rather
than as part of the surrounding template string, that can be done with rules of
the form:</p>

<pre>start ` template
start } template RIGHT3

template \${ template1 DOC
template !..~ template1
template \s \n template

template1 ${ start LEFT3
template1 !..~ template1
template1 \s \n template DOC
</pre>

<p>The <code>template</code> state looks ahead for the opening <code>$
{</code> and terminates the template string. The <code>template1</code> state
tags <code>${</code> as <code>LEFT3</code> and goes to the <code>start</code>
state to scan the inner expression. When the closing <code>}</code> is matched,
the scanner returns to process more of the template string.</p>

<p>Suppose a language description contained the following rules:</p>

<pre>even \a..z odd
odd  \a..z even
</pre>

<p>An error would be reported, because this could result in an infinite loop
when scanning. A more subtle example of an error might be:</p>

<pre>start . dot

dot  0..9         number
dot  \a..z \A..Z  prop SIGN
dot  \            start SIGN

prop  a..z A..Z 0..9  prop
prop  \               start PROPERTY
</pre>

<p>The idea behind these rules is that if a dot is followed by an identifier,
the identifier should be highlighted differently, as a <code>PROPERTY</code>.
However, the <code>prop</code> state can occur at the start of a token because
it follows the completion of a <code>SIGN</code> token in the second
<code>dot</code> rule. On the other hand, it can also occur after the start of
a token, because it is the target of its own first rule. This can be corrected
by writing:</p>

<pre>dot  0..9  number
dot  \     prop SIGN

prop  a..z A..Z  prop1
prop  \          start

prop1  a..z A..Z 0..9  prop1
prop1  \               start PROPERTY
</pre>

<p>Now, <code>prop</code> can only occur at the start of tokens and matches the
first letter, and <code>prop1</code> can only occur after the start and
recognizes the rest of the token.</p>

<h2>Tests</h2>

<p>A language description can contain tests, which also act as examples
illustrating the operation of the rules. A line starting with <code>></code>
represents a line of source text. An immediately following line starting with
<code>&lt;</code> represents the output from the scanner. For example:</p>

<pre>&gt; (count + 1)
&lt; LI    _O_VR.
</pre>

<p>The output has the one-letter abbreviation for the type of each token, placed
under its first character. A space is marked as an underline and a newline is
marked as a dot. The scanner state after scanning the input line is used as the
start state for the next test, which allows for extended examples.</p>

<h2>Specific languages</h2>

<p>Regardless of what a language standard may say, Snipe applies some
restrictions to source text across all languages. In particular, no encoding is
supported other than UTF-8, no newlines are allowed other than <code>\n</code>,
and no other control characters are allowed. In addition to those restrictions,
each language has its own peculiarities:</p>

<h4>The C language</h4>

<p>In the C language, digraphs, trigraphs and line joiners are supposed to be
handled by preprocessing. Digraphs and trigraphs are long-obsolete, and are not
supported. An occasional line joiner (i.e. backslash before newline) is,
however, still found, particularly in <code>#define</code> directives, so it is
supported, except in pathological cases such as in the middle of a
keyword.</p>

<p>For semicolon insertion purposes, operators which can be infix or unary are
treated as infix. The most likely situation where this could cause confusion
is:</p>

<pre>n = 0
*p = 0
</pre>

<p>No automatic semicolon is inserted at the end of the first line, so an
explicit manually inserted semicolon is needed. Operators which are unary are
treated as nonfix, on the assumption that they won't be separated by a newline
from their operands.</p>

<p>Open brackets are naturally regarded as prefix, and close brackets as
postfix. This works for round and square brackets, and also for curly brackets
when they are used as structure brackets. However, when curly brackets are used
as block brackets, they behave unusually. Blocks are usually attached to the
end of statements:</p>

<pre>if (n &lt; 0)
{
    n = -n
}
</pre>

<p>The line with the curly bracket is a continuation of the preceding statement.
Thus an open block bracket does no expect a semicolon before or after it, and
so an open block bracket, tagged with <code>BEGIN</code> instead of
<code>LEFT</code>, is treated as infix. Block brackets can be compared with
structure brackets:</p>

<pre>if (...) { n = -n; }
obj = { ... };
</pre>

<p>A close block bracket expects a semicolon before it but not after it, rather
than after it but not before it. Thus a close block bracket, marked
<code>END</code> rather than <code>RIGHT</code>, is treated as prefix instead
of postfix. The C language allows standalone blocks:</p>

<pre>int n = 1, m = 2
{ int temp = n; n = m; m = temp; }
</pre>

<p>This situation is rare, and doesn't follow the normal rule, so an explicitly
entered semicolon is required.</p>

<p>The C language definition tags the open bracket of a structure as
<code>BEGIN</code> by default, but <code>LEFT</code>in these common cases:</p>

<pre>enum {...
struct {...
enum ID {...
struct ID {...
= {...
= ( ID ) {...
= ( struct ID ) {...
</pre>

<p>It is reasonable for a programmer to stick to these cases and avoid more
obscure ones. The Snipe bracket matcher changes the tag of the close bracket
from <code>END</code> to <code>RIGHT</code>.</p>

<h4>The JavaScript language</h4>

<p>There are two places where fully correct scanning of the language depends on
parsing context.</p>

<p>The first is the ambiguity between <code>/</code> used as a division operator
and <code>/</code> as the first character of a regular expression pattern such
as <code>/[a-z]+/</code>. The language definition takes simple local approach.
When preceded by a prefix or infix token such as an open bracket or operator, a
regular expression pattern is expected, otherwise a division operator is
expected. So, in rare cases such as after a close bracket or certain keywords,
a regular expression pattern needs to be bracketed to be recognised correctly.
For example:</p>

<pre>if (n>0) (/pattern/).exec(...)
</pre>

<p>The second place where parsing context is used is with template strings,
which can contain arbitrary substitution expressions:</p>

<pre>s = `x = ${...} and y = ${...} and z = 0`
</pre>

<p>The parser needs to match the curly brackets and backquotes within a <code>$
{...}</code> substitution expression, so that it can recognise the
<code>}</code> which returns to the outer template string. It is not possible
to do that with a state-based scanner. So the Snipe language definition only
supports simple substitution expressions, in particular not ones involving
curly brackets, or template strings, or most keywords, or comments.</p>

<p>JavaScript has its own semicolon insertion rules. That means a Snipe user has
the choice of using JavaScript's rules, or the Snipe rules, which are much
simpler. In fact, the approach in the JavaScript language definition uses the
language's automatic insertion to simplify its own rules. Curly brackets are
always tagged <code>BEGIN</code> and <code>END</code>. That means when curly
brackets are used for structures, no semicolon gets added. For example:</p>

<pre>obj = { x:1 }
n = obj.x
</pre>

<p>The Snipe scanner does not insert a semicolon in this case, on the assumption
that the JavaScript conventions will.</p>

<p>JavaScript has a few extra conventions which come into play when it is
embedded in a <code>script</code> element in an HTML page. Those conventions
are not covered by the Snipe language description.</p>

<hr/>

<h3>Scanner operation</h3>

<p>The first state to be defined in a language description is the default one
for the scanner to start in. It is normal for most tokens to be scanned starting
from that first state, with other states being defined to handle progression
through each token. In that case, re-scanning is sure to be brief. However,
alternative start states for tokens can be used to handle unusual
situations.</p>


<h3>Bracket Matching</h3>

<p>TODO: explain forward algorithm. Assume only brackets. As well as text, there
are two stacks: unmatched and matched. (Picture with ... for cursor position.)
The unmatched stack contains indexes of currently unmatched open brackets (as
standard). The matched stack contains matched (open,close) pairs of indexes. The
indexes of the close brackets are in text order. Changes as you add or remove a
bracket at the cursor are very small and incremental and efficient.  Two
mismatched brackets are treated as matched, except that they are both
highlighted as invalid. Incremental.</p>

<p>TODO: explain backward algorithm. Entirely symmetrical. Note that the indexes
are measured leftwards from the end of the text, so that they remain stable as
insertions and deletions happen at the cursor.</p>

<p>TODO: explain inwards algorithm. The two stacks are compared inwards.
Mismatching pairs are highlighted red. Remaining surplus brackets are
highlighted red. Give examples showing 'just typed' effects.</p>

<p>After scanning into tokens, a matching algorithm is used to pair up brackets
and delimiters. Some aims of the Snipe approach are to:</p>

<ul>
<li>highlight unmatched brackets and delimiters</li>
<li>have small edits produce small changes</li>
<li>make the algorithm incremental</li>
</ul>

<p>If brackets don't match, there is an ambiguity about which brackets to mark
as unmatched. For example, the sequence <code>(()</code> can be treated in
either of these two ways:</p>

<pre class="match">(<b>(</b>)
<b>(</b>()
</pre>

<p>In the first case, the outer brackets are matched and the inner one is
highlighted as unmatched. In the second case, the rightmost brackets are
matched, and the leftmost one is marked as unmatched.</p>

<p>If the user has just typed one of the two open brackets, that is the one that
is most intuitively highlighted as unmatched. That suggests a matching algorithm
based on the user's history. However, that would make it awkward to save and
reopen files, and it could easily become counter-intuitive.</p>

<p>Instead, Snipe uses a matching strategy which is based purely on the text
together with the user's current cursor position. Brackets are matched forwards
from the start of the text up to the cursor, and backwards from the end of the
text to the cursor. Surplus brackets on either side of the cursor are then
matched up from outermost to innermost. Using three dots to mark the cursor
position, the three brackets above are handled like this:</p>

<style>
pre.match { color: black; }
pre.match i { color:black; font-style: normal; background-color: lightgrey; }
pre.match b { color: red; }
pre.match u { color: green; text-decoration: none; }
</style>

<pre class="match">(<b>(</b><u>...</u>)
<b>(</b><u>...</u>()
</pre>

<p>In the first case, there are two surplus brackets before the cursor and one
after, and the outermost two are matched. In the second case, there are no
surplus brackets after the cursor, so the leftmost bracket is mismatched.</p>

<p>The situation is complicated by multiline comments. Let's suppose that they
are delimited by <code>/*</code> and <code>*/</code> and that these don't nest,
as in many C-like languages. These comments cause two main problems. One is that
commenting out goes wrong when there is an inner comment. The other is that
inserting or deleting a comment delimiter can cause a large amount of text to be
re-scanned, which is sometimes inefficient enough to cause a noticeable and
irritating delay. In any case, it causes a large amount of changed highlighting
on screen, which can be annoying.</p>

<p>The approach in Snipe, to avoid these problems, is to treat <code>/*</code>
as illegal inside comments (as <code>*/</code> already is) and, as with
brackets, use both forward and backward matching. In addition, the effect of an
unmatched comment delimiter only extends as far as the cursor. For example:</p>

<pre class="match"><i>/*...<b>/*</b>...*/</i>...<b>*/</b>
<b>/*</b>...<i>/*...<b>*/</b>...*/</i>
</pre>

<p>In the first case, the cursor is beyond the text fragment. The first and
third delimiters are matched, and the text between is highlighted as a comment.
The second and fourth delimiters are highlighted as unmatched. This is as
expected, except for the highlighting of the second delimiter.</p>

<p>In the second case, the cursor is before the text fragment. Working
backwards, the fourth and second delimiters are matched, with the text between
them highlighted as a comment, leaving the third and first delimiters unmatched.
Although this highlighting doesn't agree with the language conventions, it is a
reasonable approach once internal delimiters are regarded as invalid, and the
need for correction is clearly indicated.</p>

<p>To see the full effect on highlighting, here is a sequence of user actions in
which an attempt is made to comment out some text which already contains a
comment:</p>

<pre class="match"><u>:</u>...<i>/*...*/</i>...
<i><b>/*</b></i><u>:</u>...<i>/*...*/</i>...
<i><b>/*</b>...</i><u>:</u><i>/*...*/</i>...
<i>/*...<b>/*</b></i><u>:</u><i>...*/</i>...
<i>/*...<b>/*</b>...</i><u>:</u><i>*/</i>...
<i>/*...<b>/*</b>...</i><i>*/</i><u>:</u>...
<i>/*...<b>/*</b>...</i><i>*/</i>...<u>:</u>
<i>/*...<b>/*</b>...</i><i>*/</i>...<b>*/</b><u>:</u>
</pre>

<p>At the first step, an opening delimiter is typed. At the second, the cursor
is moved past some text, which becomes highlighted as comment. Then the cursor
is moved past the second opening delimiter, which becomes highlighted as
unmatched. The first and third delimiters match, as surplus delimiters either
side of the cursor. Then the cursor is moved past some text which is unchanged,
and a final delimiter is typed, which is immediately highlighted as
unmatched.</p>

<p>During the sequence, the only changes on the screen are immediately adjacent
to the cursor, with possibly one change of highlighting to a delimiter further
away. And the changes are, arguably, very intuitive.</p>

</body>
</html>
