<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" xml:lang="en-GB">
<head>
<meta charset="UTF-8"/>
<style>
    body { font-size: 120%; }
    pre, .indent { margin-left: 40px; }
    img { display: block; margin: 0 auto; }
    mark {
      font-family: cursive;
      font-size: 95%;
      color: #080;
      background-color: white;
    }
</style>
<title>Building Snipe</title>
</head>
<body>

<h1>Building from source</h1>

<p>Binary releases are provided for each of three main platform families. They
should work for most users. It is the simplest approach, avoiding the
creation of platform-specific installers or the inclusion of the
editor in a wide range of software repositories. For other platforms, or
unusual variations, Snipe has to be compiled from source.</p>

<p>If the binary release for your platform doesn't work for you, this is
almost certainly because there is something awkward about your computer which
may be difficult to track down, so the instructions here are far from
foolproof.</p>

<p>One possibility is that OpenGL is not installed on your
computer. It is possible that you may be able to install it and then use the
binary release, so that is worth checking first. Otherwise try the
instructions for the closest platform family. If necessary, check the
background information at the end of this page.</p>

<h2>General</h2>

<p>This applies to all platforms. Download the Snipe source code using the
source zip file in the latest release. Work in the <code>src</code>
directory.</p>

<p>Any module can be compiled and tested individually, e.g. the
<code>file</code> module can be tested with <code>make file</code>. This will
compile the module into an executable file <code>snipe</code> (or
<code>snipe.exe</code> on Windows), and then run it to execute the module's
unit tests.</p>

<p>The command <code>make snipe</code> will build the whole editor,
which can be run with <code>./snipe</code> or it can be copied to the directory
above and run with <code>../snipe</code> to move it out of the way of
subsequent unit tests.</p>

<p>The modules most likely to cause difficulties, and which should probably be
tested separately before building the whole editor, are <code>font</code>,
<code>handler</code> and <code>display</code>.</p>

<p>The command <code>make font</code> causes the <code>freetype</code> library
to be built. Since the cut down source of the freetype library provided
has no dependencies, this is quite likely to work. If it doesn't,
<code>freetype</code>'s own make system will have to be investigated.</p>

<p>The command <code>make handler</code> causes the <code>glfw</code> library
to be built from the sources provided. This is a complex build, first using
<code>cmake</code> to configure <code>glfw</code> for your computer, then
<code>make</code> to compile the result. Finally the compiler arranges to
dynamically link the resulting program with a collection of system libraries
(to do with window, mouse and keyboard handling). Although there is a typical
list of libraries in the Makefile, the list does differ between computers, and
this is the most likely problem area.</p>

<p>The command <code>make display</code> causes the OpenGL library to be
linked, as well as <code>glfw</code>. As long as OpenGL is available on
your computer, this is likely to work. If not, it is possible that further
system libraries are needed.</p>

<h2>Linux or other Unix-based systems</h2>

<p>First make sure <code>git</code>, <code>make</code> and <code>cmake</code>
are installed, or install them with commands such as <code>sudo apt install
git</code> or equivalent.</p>

<p>Check that the command
<code>uname -s</code> produces something containing <code>Linux</code> or
change
<code>Makefile</code> so that it recognizes whatever is produced. Change
<code>gcc</code> in the <code>Makefile</code> to <code>clang</code> if it
helps (e.g. if your <code>gcc</code> is old and difficult to upgrade, so
that installing <code>clang</code> is a better option).</p>

<p>One way to find the necessary libraries (in fact the technique used to
create the original list) is to install <code>glfw3</code> temporarily
with a command such as <code>sudo apt install libglfw3-dev libglfw3</code>
and then use <code>pkg-config --static --libs glfw3</code> to list the
libraries needed for dynamic linking when <code>glfw</code> is compiled
statically into a program, as with Snipe. The libraries can be copied into the
Makefile. If that works, they can be deleted one by one to see which ones
are actually necessary.</p>

<h2>Macs</h2>

<p>The first step is to install <code>homebrew</code> from its web site. This
has three good effects. Installing it causes the command line tools associated
with XCode to be installed (without the IDE which is not recommended for
cross-platform programmers). It provides the command <code>brew</code> which
acts as a package manager to install further software. And it provides
the command <code>brew doctor</code> which checks consistency of installed
software, and suggests fixes if it finds problems. Install <code>cmake</code>
with <code>brew install cmake</code>. The commands <code>git</code> and
<code>make</code> should be already installed. The <code>gcc</code> command
is probably a synonym for the Mac version of <code>clang</code>.</p>

<p>Download the Snipe source using the source zip file in the latest release.
Work in the <code>src</code> directory. Check that the command
<code>uname -s</code> produces something containing <code>Darwin</code> or
change
<code>Makefile</code> so that it recognizes whatever is produced.</p>

<h2>Introduction</h2>

<p>Some general
information about building OpenGL/GLFW programs for the three main platforms can
be gleaned from sites like <a
href="http://web.eecs.umich.edu/~sugih/courses/eecs487/glfw-howto/">this
how-to</a>.</p>

<p>The main implementation goals are for <mark>Snipe</mark> to:</p>

<ul>
<li>be cross-platform</li>
<li>be fast-loading</li>
<li>have a single code base</li>
<li>provide portable binaries</li>
</ul>

<p>A variety of libraries have been tried (in several programming languages) to
achieve cross-platform graphics. Higher level libraries are unsatisfactory,
because they are typically very large, with extensive dependencies. That means
programs using them are only fast-loading on their native platforms, and then
only if the libraries have already been loaded into memory by other
applications. In the end, low level C libraries have been chosen:</p>

<ul>
<li><a href="https://www.freetype.org/">Freetype</a> for fonts</li>
<li><a href="http://www.glfw.org/">GLFW</a> for event handling and window control</li>
<li><a href="https://www.opengl.org/">OpenGL</a> for graphics rendering</li>
</ul>

<p>OpenGL is reliably available across most platforms, without users having to
install it. The only current problems with it appear to involve old versions of
Windows or obscure features, neither of which are very relevant to
<mark>Snipe</mark>. It is old, which is good for supporting old computers.
Using Vulkan (replacement open standard, not currently widely available without
installing a driver) or Metal (for Macs only, given that OpenGL may be dropped)
will probably become appropriate at some point.</p>

<p>To produce reasonably portable binaries for each of the three main platform
families, Freetype and GLFW are statically linked. The sources of Freetype and
GLFW are included with the project. Freetype is cut down to a minimum,
supporting only <code>.ttf</code> font files, so that it becomes small and has
no further dependencies. OpenGL (which is effectively a device driver and
therefore not portable, even within the same platform family), and the standard
system libraries needed by GLFW (similarly not portable), are dynamically
linked.</p>

<p>The only reasonable programming languages to use in the implementation, given
this choice of low level libraries, are C or C++. C has been chosen as, used
with care, it is simpler. There are no real practical advantages of C++, given
that no specific C++ libraries are needed.</p>

<p>It is desirable to have similar build environments on all three main platform
families. A command line build environment works well on Linux and MacOS, but
takes more care to set up on Windows.</p>

<h2>Building on Windows</h2>

<p>The Windows C compiler is avoided, to make sure the same compiler, meeting
the C11 standard, is used on all platforms. On the other hand, Cygwin is
unsuitable, because of the need to create a native binary with convenient
graphics testing and without a large extra DLL. Instead, MSYS2 is used, which is
built on <code>mingw-w64</code>, adding a shell window and the
<code>pacman</code> package manager. When setting up MSYS2, care is taken to
install <code>mingw-w64-x86_64-gcc</code> rather than the default version of
<code>gcc</code> to support native compiling and avoid the need for a
Cygwin-like DLL. Similarly, <code>mingw64/mingw-w64-x86_64-cmake</code> is
installed rather than the default <code>cmake</code>, and so on. To meet the C11
standard uniformly across platforms, the <code>long</code> type is avoided, and
very careful use is made of C library functions. Also
<code>setbuf(stdout,NULL)</code> is included in every <code>main</code>, to
counter the indirect handling of <code>stdout</code> on MSYS2, which causes
buffering. A few Posix functions beyond the C11 standard are required to handle
directories properly, but fortunately the MSYS2 environment provides what is
needed.</p>



<h2>Portability</h2>


<p>On Windows, the binary created uses calls to system libraries which have been
standard for some time, and there are no known difficulties.</p>

<p>MacOS has yet to be tackled, but the situation is expected to be similar to
Linux.</p>

<!--
<p>To create a single Linux binary which covers a reasonable range of Linux
platforms, dependencies on system libraries (checked with <code>ldd</code>) are
kept low. In addition, as described <a
href="http://insanecoding.blogspot.com/2012/07/creating-portable-linux-binaries.html">here</a>,
<code>objdump</code> is used to find problematic GLIBC library functions which
normally require recent versions of the GLIBC library. Using a method similar to
<a href="https://github.com/wheybags/glibc_version_header">this</a>, those
problem functions are declared as older versions, making the binary compatible
with more platforms. This requires the <code>asm</code> feature of
<code>gcc</code> but avoids the need for a special build environment.</p>
-->
<h2>Dependencies</h2>

<p><mark>Snipe</mark> is implemented using small and well-encapsulated modules,
with low dependencies and no dependency cycles, each including its own unit
testing. The main dependency issue is how the logic of a program (the model) and
the graphics (the view) are related. The style chosen for <mark>Snipe</mark> is
to divide all the modules into four main groups:</p>

<img src="MVC.png" />

<p>The controller asks for events from the view, sends them as actions to the
model, then asks the model for data to send to the view to update it. This is a
variant of the Model-View-Controller design pattern, with lower dependencies
than usual. This avoids any cyclic dependency, especially between the view and
the model, which would make development unreasonably difficult. It avoids having
a lot of modules dependent on graphics, which would make testing unreasonably
difficult. And it avoids having the view depend on anything much other than
graphics library facilities, which helps to keep it simple and independent.</p>

<p>The detailed list of modules and their dependencies is recorded in only one
definitive place, the <a href="Makefile">Makefile</a>. The modules are listed
there in dependency order, with each depending only on the modules above so
that, in any development step, the modules can be upgraded and tested one by one
in the order listed.</p>

<h2>Style of C</h2>

<p>To make modules independent, and their dependencies clear, each module has
its own header file which defines its API. None of the module headers mention
anything related to the OpenGL or GLFW APIs, isolating the use of those
libraries to the modules that need them. (Isolating libraries in this way in C++
can be surprisingly difficult, e.g. involving the PIMPL strategy.)</p>

<p>In order to make modules robust, most are encapsulated by
defining an opaque structure in the header:</p>

<pre>struct X;
typedef struct X X;
</pre>

<p>This ensures that normal code cannot see inside or damage the structure, and
can only access it by making official function calls.</p>

<p>It is normal to guard against multiple inclusion of headers using
preprocessor guards. But that is aesthetically ugly, and the care taken over
dependencies makes multiple inclusion problems rare. Function prototypes, opaque
structure declarations and (since C11) typedefs are safe to include multiple
times, so enumerated types are effectively the only problem.</p>

<p>Enumerated types in C are not type-safe. It is possible to use typesafe
opaque constants, but they are tedious to define and awkward to use and, in
particular, they can't be used in switch statements. So conventional C
enumerated types are used. An enumerated type such as <code>event</code> is
defined in its own module. The header <code>event.h</code> contains:</p>

<pre>enum event { ... };
typedef int event;
</pre>

<p>Note that a declaration <code>typedef enum event event</code> is possible,
but is less flexible because it requires the enumeration to be in scope. In
addition, it gives a false sense of type safety, and it effectively prevents the
use of <code>-1</code> as an exceptional value, at least when compiler
optimization is switched on. The header <code>event.h</code> is included only in
implementation <code>.c</code> files, not in other header files. If the
<code>event</code> type is needed in another header in order to define an API,
that header uses the line:</p>

<pre>typedef int event
</pre>

<p>instead of the line:</p>

<pre>#include "event.h"
</pre>

<p>With these conventions, headers cause no multiple inclusion problems.</p>

</body>
</html>
