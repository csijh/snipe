<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" xml:lang="en-GB">
<head>
<meta charset="UTF-8"/>
<style>
body { font-size: 120%; }
pre, .indent { margin-left: 40px; }
img { display: block; margin: 0 auto; }
mark {
    font-family: cursive;
    font-size: 95%;
    color: #080;
    background-color: white;
}
</style>
<title>Snipe Features</title>
</head>
<body>

<h1>Features</h1>

<p>The actions corresponding to keyboard and mouse gestures can be gleaned
from the file <a href="../files/map.txt">files/map.txt</a>, which can be
customised. There are also some general settings in the file
<a href="../settings.txt">settings.txt</a>.</p>

<h2>Bracket matching</h2>

<p>Round, square and curly brackets <code>()[]{}</code> on each line are
matched, and mismatched brackets are syntax-coloured as errors. Care is taken
over the way in which brackets are matched, because it affects
auto-indenting.</p>

<p>Only syntactically meaningful brackets are matched. Others are assumed to be
inside comments or strings. Brackets which are unmatched rather than mismatched
are not marked as errors. Instead, they affect indenting.</p>

<p>Where there is a mismatched pair of brackets <code>(]</code> say, only one is
marked as an error where reasonably possible, e.g. if the pair appears in the
context  <code>(]...)</code> or <code>[...(]</code> only the middle bracket is
marked as an error.</p>

<h2>Auto-indenting</h2>

<p>Most editors provide something that ought to be called semi-auto-indenting.
It works well when typing new program text. But it typically works badly when
changing existing text. The result is that, for most programmers, there is
little or no net gain.</p>

<p><mark>Snipe</mark> provides full auto-indenting (currently just for .c and
.h files). The idea is that, in exchange for a small
and hopefully painless loss of control over indenting, the user need never think
about or adjust indenting ever again. The amount of indent on a line is
determined by simple rules, as explained below, and maintained during all
editing operations. <!-- The cursor can't be placed inside the indent - it
moves back and forth past the indent as if it wasn't there.-->  An attempt made
to change the indent fails, because it is immediately corrected.</p>

<p>It is challenging to come up with rules which are simple to understand and
implement, which are immediately apparent to the eye, which work across a wide
range of languages, which work even when a program is not in a syntactically
correct state, which cope with continuations of single statements onto multiple
lines as well as blocks of statements, which support all the common indenting
styles, and which the majority of programmers can learn to accept comfortably
without irritation.</p>

<p>The rules chosen are adapted from Python, and should work across all
curly-bracket-based languages, and possibly many more. The rules work on a
line-by-line basis, based on unmatched bracket characters <code>()[]{}</code>
whether round, square or curly. Only syntactically active brackets (i.e. ones
not inside comments or strings) count.</p>

<p>An <dfn>indenter</dfn> is an unmatched open bracket, and an
<dfn>outdenter</dfn> is similarly an unmatched close bracket. Each indenter
causes the indent to be increased, starting on the following line. An outdenter
causes the indent to be decreased, starting on the following line, or on the
same line if there is an outdenter at the start.</p>

<p>Comment lines currently follow these indenting rules, as well as
ordinary code. The indent of a blank line is temporarily zero. The feature
currently supports the two most popular
<a href="https://en.wikipedia.org/wiki/Indentation_style">indenting styles</a>,
K&amp;R and Allman, and to a lsser extent, some other styles such as Horstmann
and Pico.</p>

<p>This feature is experimental, and currently a bit rough. The cursor needs to
be kept out of the indent area, and a newline and following indent need to be
treated like a single character.
The handling of
blank lines and trailing spaces on the ends of lines needs to be improved.
The feature needs to be enabled and controlled from language definition files so
that, for example, more indent styles can be supported, labels and cases in
switches can be handled specially, and keywords can be marked as indenters or
outdenters so that more languages can be supported. It isn't clear whether the
continual movement in and out of the code below the line being edited will
seem natural after a while, or whether it needs improvement, perhaps by not
repairing indents below a line until the cursor moves off it.</p>

<h2>Help</h2>

<p>Typing CTRL+H makes a help page appears in the browser. The command to do
that varies by platform. Unfortunately, this tends not to be very reliable,
so it may need to be customized in the settings file.</p>

<h2>File menu</h2>

<p>Typing CTRL+O makes a file menu appears. Choose a line with the arrow keys
or mouse, and press ENTER to load a file. Later, double clicking and syntax
highlighting will be added.</p>

<h2>Line endings</h2>

<p>Files are always written out using <code>\n</code> line endings. The
Windows convention <code>\r\n</code> and old Mac convention <code>\r</code> are
accepted and converted on input. This follows the advice of the <a
href="http://utf8everywhere.org/">UTF-8 everywhere manifesto</a> which
recommends using <code>\n</code> line endings everywhere. All sensible tools on
Windows accept <code>\n</code> line endings. The most obvious exception is
Notepad, but there are other good reasons to avoid using that.</p>

<h2>No buffer</h2>

<p><mark>Snipe</mark> creates the illusion of editing a file directly, not a
copy in a buffer. This gets rid of an unnecessary extra complication in the
user's mental model, and removes the need for frequent saving, which is entirely
routine and therefore should be automated. Autosave becomes a necessary feature
of <mark>Snipe</mark> rather than an option. <mark>Snipe</mark> doesn't create
backups of files, on the basis that programmers use other tools such as
<code>git</code> for that. Autosaving is done frequently.</p>

<h2>Final newline</h2>

<p>Files are always written out with a final newline. A file without a
final newline has one added when it is read in. That's because: (a) most tools
expect a final newline and all tools tolerate it (b) some standards require it
and (c) the opposite convention, treating <code>\n</code> as a separator, is not
sensible because there is no way to represent an empty file as opposed to a file
with a single blank line.</p>

<p>The final newline convention is also maintained during editing, in line with
having no notional buffer. The more usual convention of treating a buffer as a
string with newlines as separators causes a surprising amount of confusion
because the editor's line count for the buffer doesn't match the normal line
count for the file. In <mark>Snipe</mark>, it is still reasonable to regard the
text as a single array of characters. The last cursor position is after the
final newline, which is naturally below the last line on the screen. However,
that apparent 'extra' line isn't given a line number or included in the line
count.</p>

<h2>Trailing blank lines and spaces</h2>

<p>A text file shouldn't have trailing blank lines, or trailing spaces on the
end of a line. It is planned to make <mark>Snipe</mark> remove such extras when
the cursor moves away from them.</p>

<h2>File separators</h2>

<p>Paths use forward slash <code>/</code> separators. Backslashes <code>\</code>
are converted to forward slashes in any paths that come from outside the editor.
The Windows libraries have always accepted forward slashes - it is only tools
that prefer backslashes. The editor refuses to handle file or directory names
that have slashes or backslashes in them, to encourage programmers to use
only platform independent names.</p>

<h2>Soft tabs</h2>

<p>Only soft tabs are supported. When files are read in, hard tabs are converted
to spaces. Other control characters are also rejected, except for newlines.</p>

<p>Hard tabs are obsolete, ambiguous, and cause all sorts of trouble. Some
tools, including printer drivers, don't handle them properly, some accept them
but with no option to specify their width, and the only common default of 8
spaces is commonly regarded as too wide for normal programs. Some public source
files use an indent width of four and a hard tab width of eight, leading to a
mixture of tabs and spaces. Such files are unreadable in any editor which
doesn't have separate settings for indent width and tab width. In any sensible
editor, soft tabs are implemented to behave just like hard tabs, so soft tabs
have no significant disadvantages.</p>

<p>When full auto-indenting is implemented, the indent width for a file will
be set according to the first indent found in the file itself, or 4 if there
aren't any. Any tab width will be allowed, but it should
be noted that widths other than 2, 4, 8 are quite unlikely to be supported in
other editors. To change the indent width of a file, rename the file to have a
<code>.txt</code> extension, change the first indent in the file, then rename it
back.</p>

</body>
</html>
