Current state (fwd):
    all brackets matched, mismatched, or stacked (single stack)
    if stack top is /*, all tokens after are marked 'COMMENT'
    - with /*
        - insert x([{)]} mark comment and move past
        - insert /* mark mismatch and move past
        - delete top of stack: pop
        - delete x
        - matched )]} can't occur
    - without /*
        - insert x move past
        - insert ([{ push
        - insert )]} match or mismatch
        - insert /* push
        - delete top of stack: pop
        - delete matched )]} move pair to stack
        - delete x
Table driven with possible <-> replacements.


Language files should contain context-sensitive adjustments, and a theme.
Adjustments for bracket/id matching, indenting, semicolons:
    classify every token as Non, Pre, In, Post
    if a PreIn operator follows Pre or In, reclassify it as Pre, else In
    if a PrePost operator follows Pre or In, reclassify it as Pre, else Post
    if OB/CB are block brackets and CB/CC are non-block-curly-brackets
        = OB   -->   OC
        = ( ... ) OB   -->   OC   (using bracket matching)
        struct . OB   -->   OC
        enum . OB   -->   OC
        OC ... CB   -->   CC
        DEF_TYPE ... USE_ID   -->   USE_TYPE   (using id OB/CB scope matching)
        what exactly are the rules for C?
        What is the order? Rules seem to be both before and after bracket-match
    bracket match
        pair up brackets, except across the gap.
        Therefore bracket module needs to track cursor movement.
        Therefore, pairing up cross-gap brackets is dynamic.
    use two successive tokens to determine implicit semicolons (see runway)
        Pre/In at end of line or In/Post at start of next prevent semicolon
================================================================================
Unicode:
    Code points.
    Not grapheme clusters? (Depends on font & font lib.)
Scanning:
    Want dynamic loading, but not regexes. Therefore current approach.
    Escaped chars? Only as whole patterns, then can't have \10 inside a pattern.
    No lookahead past newlines, then can re-start.
    Where store state? Per line? In any continuation, including indents?
Store:
    Gap buffer still looks good, but need good API.
    Store more per line.
    Use row/col positions throughout.
================================================================================
TODO Switch to using Allegro.
Find out from allegro.cc how to package for different platforms.
Check that the result is small on each platform.

TODO Remove POINT, SELECT from style flags. Remove START in favour of a single
CONTINUE value for token boundaries. Add CONTINUE_GRAPHEME for grapheme
boundaries. Add BAD as a flag so it can be removed again or displayed as a box,
say.

TODO Break up comments, strings etc. as mini-tokens, so that scanning is context
free. Treat and display in two ways, according to line state. MAYBE NOT.

TODO Consider storing lines as byte-for-byte, base 256 line count or something.
Consider doing everything line-based instead of byte-based, with row+col points,
making it much easier to store per-line info, & do per-line bracket matching.

TODO Sort out bracket matching.
A) Store all indenters/outdenters, i.e. out-of-line brackets, in a gap buffer.
   Each entry has index into text, reference to mate.
B) Do incremental bracket matching, forwards and backwards.
   For example: delete-backwards closing-bracket B:
   - check if B is last out-of-line bracket in array before gap
   - if so, unmark mate and remove
   - if not, must be inline, check colour byte to see if mismatched and delete
   - if not, scan back through line to find mate
================================================================================
Current modules:

unicode: used by file, handler, includes utf16 for win.
list:  flex array with odd direct indexing.
array: flex array with odd pre-length and resize conventions.
string: split(lines/words), normalize.
setting: read settings file
style: constants.
action: command/event
